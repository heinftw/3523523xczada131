--[[   v14.7 - COMPREHENSIVE FIX
COMPLETE REWRITES:
- Aimbot (simplified direction calc)
- Auto Pass (fresh teammate detection, no race conditions)
- Hit Effects (single-select, all players, no time checks)
- Ball Detection (Ball Shadow ONLY)
- Movement Stats (instant persistence, debuff-aware)
- Auto Rotation (improved net crossing detection)
REMOVED: Dash Speed, No Ability CD, No Serve CD
]]

-- UI LIBRARY (LINES 1-30 - MANDATORY)
local Fluent=loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local SaveManager=loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager=loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()

local Window=Fluent:CreateWindow({Title="  v14.7 - Rewritten",SubTitle="All Systems Fixed",TabWidth=160,Size=UDim2.fromOffset(580,420),Acrylic=false,Theme="Dark",MinimizeKey=Enum.KeyCode.End})

local Tabs={Position=Window:AddTab({Title="Positions",Icon="map-pin"}),Main=Window:AddTab({Title="Main",Icon="home"}),Combat=Window:AddTab({Title="Combat",Icon="crosshair"}),Stats=Window:AddTab({Title="Stats",Icon="trending-up"}),Effects=Window:AddTab({Title="Effects",Icon="zap"}),Misc=Window:AddTab({Title="Misc",Icon="settings"}),Settings=Window:AddTab({Title="Settings",Icon="sliders"})}

SaveManager:SetLibrary(Fluent)
SaveManager:IgnoreThemeSettings()
SaveManager:SetFolder("RacketRivals_v146_Fixed")

InterfaceManager:SetLibrary(Fluent)
InterfaceManager:SetFolder("RacketRivals_v146_Fixed")

if getgenv().RacketRivalsV147Loaded then return end
getgenv().RacketRivalsV147Loaded=true

-- ═══════════════════════════════════════════════
-- [ENI] V15 BYPASS — LOADS BEFORE EVERYTHING ELSE
-- ═══════════════════════════════════════════════
do
    local _RS = game:GetService("ReplicatedStorage")
    local _Http = game:GetService("HttpService")
    local _WS = game:GetService("Workspace")

    local _ActionsModule = _RS:WaitForChild("Actions")
    local _ActionRemote  = _ActionsModule:WaitForChild("Action")
    local _InvokablesDir = _ActionsModule:WaitForChild("Invokables")

    local _isExecutorCall = checkcaller
        or (getthreadidentity and function() return getthreadidentity() >= 6 end)
        or function()
            local src = debug.info(4, "s")
            return not src or src == "" or src == "[C]"
        end

    local _Actions = require(_ActionsModule)

    local _Bitbuf = (function()
        for _, act in pairs(_Actions) do
            if type(act) == "table" and act.Invoke then
                for i = 1, 60 do
                    local s, v = pcall(debug.getupvalue, act.Invoke, i)
                    if s and type(v) == "table" and v.new and rawget(v, "new") then
                        return v
                    end
                end
            end
        end
        return nil
    end)()

    if not _Bitbuf then
        warn(">>> [ENI] V15 FATAL: Bitbuf not found")
    else
        local function _buildPacket(jsonPayload)
            local buf = _Bitbuf.new()
            local uSz = math.random(42, 48)
            if (uSz + 9 + 19) % 8 == 0 then uSz = uSz + 1 end
            buf:writeUnit(9, uSz)
            buf:WriteUint(uSz, math.floor(_WS:GetServerTimeNow()))
            buf:writeUnit(19, #jsonPayload)
            buf:WriteBytes(jsonPayload)
            buf:writeUnit(math.random(5, 10), math.random(1, 31))
            return buf:String()
        end

        local _nameCache = {}

        local function _getObfName(actionName)
            if _nameCache[actionName] then return _nameCache[actionName] end
            local ok, act = pcall(function() return _Actions[actionName] end)
            if ok and type(act) == "table" and act.name then
                _nameCache[actionName] = act.name
                return act.name
            end
            return nil
        end

        local function _BypassFire(actionName, ...)
            local name = _getObfName(actionName)
            if not name then return false, "could not resolve: " .. tostring(actionName) end
            local args = {...}
            local payload = {name}
            for i = 1, #args do payload[i + 1] = args[i] end
            local canJson, json = pcall(_Http.JSONEncode, _Http, payload)
            if canJson then
                _ActionRemote:FireServer(_buildPacket(json))
            else
                _ActionRemote:FireServer(name, ...)
            end
            return true
        end

        local function _BypassInvoke(actionName, ...)
            local name = _getObfName(actionName)
            if not name then
                return nil, "could not resolve: " .. tostring(actionName)
            end

            local rf = _InvokablesDir:FindFirstChild(name)
            if not rf then
                return nil, "no RF for: " .. tostring(actionName)
            end

            -- Try Bitbuf packet first (matches game's encoding)
            local args = {...}
            local canJson, json = pcall(_Http.JSONEncode, _Http, args)
            if canJson then
                local encOk, encRes = pcall(function()
                    return rf:InvokeServer(_buildPacket(json))
                end)
                if encOk and encRes ~= nil then return encRes end
            end

            -- Fallback: raw args (some RFs don't accept Bitbuf)
            return rf:InvokeServer(...)
        end

        local _Bypass = {
            Fire           = _BypassFire,
            Invoke         = _BypassInvoke,
            GetObf         = _getObfName,
            Bitbuf         = _Bitbuf,
            BuildPacket    = _buildPacket,
            ActionRemote   = _ActionRemote,
            InvokablesDir  = _InvokablesDir,
        }

        shared.ActionBypass = _Bypass
        _G.ActionBypass = _Bypass

        warn(">>> [ENI] V15 BYPASS READY — zero hooks on Actions table")
    end
end

-- SERVICES (COMPRESSED)
local Players,RS,RF,UIS,Run,SG,TS,Tween,WS,Debris,VIM,Http=game:GetService("Players"),game:GetService("ReplicatedStorage"),game:GetService("ReplicatedFirst"),game:GetService("UserInputService"),game:GetService("RunService"),game:GetService("StarterGui"),game:GetService("TeleportService"),game:GetService("TweenService"),game:GetService("Workspace"),game:GetService("Debris"),game:GetService("VirtualInputManager"),game:GetService("HttpService")
local LP,Cam=Players.LocalPlayer,WS.CurrentCamera

-- CORE VARIABLES (COMPRESSED)
local function Notify(t,x,d) task.spawn(function() pcall(function() SG:SetCore("SendNotification",{Title=tostring(t),Text=tostring(x),Duration=tonumber(d) or 2}) end) end) end
local function PK(k) task.spawn(function() pcall(function() VIM:SendKeyEvent(true,k,false,game) task.wait(0.01) VIM:SendKeyEvent(false,k,false,game) end) end) end

local GM,MC,ML={},{},false
local function LM(p,n) if MC[n] then return MC[n] end local s,r=pcall(function() return require(p) end) if s then MC[n]=r return r end return nil end

task.spawn(function()
if not game:IsLoaded() then game.Loaded:Wait() end
if not LP.Character then LP.CharacterAdded:Wait() end
task.spawn(function() GM.SharedData=LM(RS.DataBins.SharedData,"SharedData") end)
task.spawn(function() GM.Actions=LM(RS.Actions,"Actions") end)
task.spawn(function() GM.Values=LM(RS.Values,"Values") end)
task.spawn(function() GM.RacketStatUtils=LM(RS.RacketStatUtils,"RacketStatUtils") end)
task.spawn(function() GM.PlayerControl=LM(RF.Classes.PlayerControl,"PlayerControl") end)
task.spawn(function() GM.MovementHandler=LM(RF.Classes.MovementHandler,"MovementHandler") end)
task.spawn(function() GM.CourtHandler=LM(RF.Classes.CourtHandler,"CourtHandler") end)
task.spawn(function() GM.RacketHandler=LM(RF.Classes.RacketHandler,"RacketHandler") end)
task.spawn(function() GM.ChargeHandler=LM(LP.PlayerScripts.ChargeHandler,"ChargeHandler") end)
local w=0 while (not GM.Actions or not GM.CourtHandler or not GM.PlayerControl) and w<50 do Run.Heartbeat:Wait() w+=1 end
ML=true
end)

local OV={ChargeDuration=1,DashCooldown=nil,CameraMaxZoom=LP.CameraMaxZoomDistance}
task.spawn(function() repeat Run.Heartbeat:Wait() until ML pcall(function() if GM.SharedData and GM.SharedData.GAME then OV.ChargeDuration=GM.SharedData.GAME.SWING_CHARGE_DURATION or 1 OV.DashCooldown=GM.SharedData.GAME.DASH_COOLDOWN end end) end)

local MyLastHitTime=0

-- Cutscene block
task.spawn(function() repeat Run.Heartbeat:Wait() until ML pcall(function() if GM.Actions and GM.Actions.CUTSCENE_PLAY then GM.Actions.CUTSCENE_PLAY:Connect(function() return end) end end) end)

-- Crowd/effects removal (compressed)
task.spawn(function()
local CRA=true
local function RCE()
pcall(function() local fx=WS:FindFirstChild("FX") if fx then local cf=fx:FindFirstChild("Crowd") if cf then cf:Destroy() end end end)
pcall(function() local courts=WS:FindFirstChild("Courts") if courts then for _,court in pairs(courts:GetChildren()) do local cm=court:FindFirstChild("ClientModel") if cm then local sfx=cm:FindFirstChild("SpecialEffects") if sfx then sfx:Destroy() end end end end end)
pcall(function() local cs=LP.PlayerScripts:FindFirstChild("Gameplay") if cs then for _,s in pairs(cs:GetChildren()) do if s.Name=="6a404c25-5aca-401f-82a4-ebf8a140b0b4" then s:Destroy() end end end end)
end
local CRC=Run.Heartbeat:Connect(function() if CRA then RCE() end end)
pcall(function() local fx=WS:FindFirstChild("FX") if fx then fx.ChildAdded:Connect(function(c) if c.Name=="Crowd" and CRA then task.wait(0.1) c:Destroy() end end) end end)
pcall(function() local courts=WS:FindFirstChild("Courts") if courts then courts.DescendantAdded:Connect(function(obj) if obj.Name=="SpecialEffects" and CRA then task.wait(0.1) obj:Destroy() end end) end end)
WS.ChildAdded:Connect(function(c) if c.Name=="FX" then task.wait(0.3) CRC:Disconnect() CRC=Run.Heartbeat:Connect(function() if CRA then RCE() end end) elseif c.Name=="Courts" then task.wait(0.3) RCE() end end)
LP.CharacterAdded:Connect(function() task.wait(1) CRC:Disconnect() CRC=Run.Heartbeat:Connect(function() if CRA then RCE() end end) end)
end)

-- Charge types loading
local CT,CTL={"Default"},false
local function SAC() pcall(function() local cf=LP.PlayerScripts:WaitForChild("ChargeHandler",10) if cf then cf=cf:FindFirstChild("Charges") if cf then for _,c in pairs(cf:GetChildren()) do if c:IsA("ModuleScript") and c.Name~="PackageLink" then table.insert(CT,c.Name) end end end end end) table.sort(CT) CTL=true end
task.spawn(function() SAC() end)

-- FILE SYSTEM (INSTANT SAVING)
local CF,BCF,CCF="RacketRivals_Positions.json","RacketRivals_Boundaries.json","RacketRivals_CharacterClone.json"
local SP,SB={},{}

local function SPC(cid,pos) if not cid or not pos then return end SP[cid]=pos pcall(function() writefile(CF,Http:JSONEncode(SP)) end) end
local function LPC() pcall(function() if isfile(CF) then local d=Http:JSONDecode(readfile(CF)) if type(d)=="table" then SP=d end else SP={} end end) end
local function SBC(cid,bz) if not cid then return end if bz then SB[cid]=bz else SB[cid]=nil end pcall(function() writefile(BCF,Http:JSONEncode(SB)) end) end
local function LBC() pcall(function() if isfile(BCF) then local d=Http:JSONDecode(readfile(BCF)) if type(d)=="table" then SB=d end else SB={} end end) end

LPC() LBC()

local BD={Position=nil,Velocity=nil,LastUpdate=0,IsValid=false}
local ActiveObject,OffsetTable,DataTable=nil,nil,nil

local function ScanForKeys(targetId)
local foundOffset,foundData=false,false
for _,v in pairs(getgc(true)) do
if type(v)=="table" then
if not foundOffset and rawget(v,"Position") and type(rawget(v,"Position"))=="number" and rawget(v,"_last") and type(rawget(v,"_last"))=="number" then OffsetTable=v foundOffset=true end
if not foundData and targetId and rawget(v,targetId) and type(rawget(v,targetId))=="string" then if #rawget(v,targetId)>15 then DataTable=v foundData=true end end
if foundOffset and foundData then break end
end
end
end

local LastGCScan = 0
local GCScanInterval = 1.5

local function FindActiveObject(immediate_part)
    local candidates = {}
    if immediate_part then
        table.insert(candidates, immediate_part)
    else
        -- early exit: active object still alive, skip expensive scan
        if ActiveObject then
            local body = rawget(ActiveObject, "Body")
            if body and typeof(body) == "Instance" and body.Parent then
                return true
            end
            ActiveObject = nil
            OffsetTable = nil
            DataTable = nil
        end
        -- throttle GC scan — this is the lag source
        if tick() - LastGCScan < GCScanInterval then return false end
        LastGCScan = tick()
        for _, v in pairs(WS:GetDescendants()) do
            if v:IsA("BasePart") and (v.Name == "Part" or v.Name == "Ball") and v.Transparency < 1 then
                table.insert(candidates, v)
            end
        end
    end
    if #candidates == 0 then return false end
    for _, obj in pairs(getgc(true)) do
        if type(obj) == "table" and rawget(obj, "Body") then
            local body = rawget(obj, "Body")
            if typeof(body) == "Instance" and table.find(candidates, body) then
                ActiveObject = obj
                local id = rawget(obj, "Id")
                if id and not OffsetTable then ScanForKeys(id) end
                return true
            end
        end
    end
    return false
end

local lastDescGC = 0

WS.DescendantAdded:Connect(function(child)
    if not child:IsA("BasePart") then return end
    if child.Name ~= "Part" and child.Name ~= "Ball" then return end

    -- already tracking valid ball — skip entirely
    if ActiveObject then
        local body = rawget(ActiveObject, "Body")
        if body and typeof(body) == "Instance" and body.Parent then return end
    end

    -- 50ms cooldown between GC scans (prevents court-load lag)
    -- but still fast enough for instant ball detection
    if tick() - lastDescGC < 0.05 then return end
    lastDescGC = tick()

    task.defer(function()
        if FindActiveObject(child) then return end
        -- GC might not have ball table yet, retry shortly
        task.delay(0.15, function()
            if not ActiveObject then FindActiveObject(child) end
        end)
    end)
end)

local LastBallSearch = 0

local function UBD()
if not ActiveObject then
    if tick() - LastBallSearch > 0.5 then
        LastBallSearch = tick()
        FindActiveObject()
    end
    BD.IsValid = false
    return
end
local body = rawget(ActiveObject, "Body")
if not body or not body.Parent then
    ActiveObject = nil
    OffsetTable = nil
    DataTable = nil
    BD.IsValid = false
    return
end
local id=rawget(ActiveObject,"Id")
local finalPos=body.Position
if OffsetTable and DataTable and id then
pcall(function()
local bufStr=rawget(DataTable,id)
if bufStr then
local cleanStr=string.sub(bufStr,10,#bufStr-15)
local buf=buffer.fromstring(cleanStr)
local off=rawget(OffsetTable,"Position")
finalPos=Vector3.new(buffer.readf64(buf,off),buffer.readf64(buf,off+8),buffer.readf64(buf,off+16))
end
end)
end
BD.Position=finalPos
BD.Velocity=rawget(ActiveObject,"Velocity") or Vector3.new(0,0,0)
BD.IsValid=true
BD.LastUpdate=tick()
end
Run.RenderStepped:Connect(UBD)

-- COURT DETECTION
local CC=nil

function GetPlayerCourt()
local ch=LP.Character if not ch then return nil end
local rt=ch:FindFirstChild("HumanoidRootPart") if not rt then return nil end
local mp=rt.Position local cts=WS:FindFirstChild("Courts") if not cts then return nil end
for _,cf in pairs(cts:GetChildren()) do
local m=cf:FindFirstChild("Map")
if m then local f=m:FindFirstChild("Floor") or m:FindFirstChild("OccludeFloor")
if f then local fp=f.Position local fs=f.Size local ex=Vector3.new(10,50,10)
local mnb=fp-(fs/2)-ex local mxb=fp+(fs/2)+ex
if mp.X>=mnb.X and mp.X<=mxb.X and mp.Z>=mnb.Z and mp.Z<=mxb.Z then return {Id=cf.Name,Folder=cf,FloorPosition=fp,FloorSize=fs,GroundY=fp.Y,Floor=f} end
end end
end
return nil
end

local function GNP()
if not CC then return nil end
local cts=WS:FindFirstChild("Courts") if not cts then return nil end
local cf=cts:FindFirstChild(tostring(CC.Id)) if not cf then return nil end
local m=cf:FindFirstChild("Map") if not m then return nil end
local col=m:FindFirstChild("Colliders") if not col then return nil end
local n=col:FindFirstChild("Net") if not n then return nil end
return n.Position,n.Size
end

-- TEAMS TRACKING (ENHANCED)
local TT={Teammates={},Opponents={},LastUpdate=0,UpdateInterval=0.01,PredictionEnabled=false,PredictionTime=0.5}
local OH={}

local function UTT()
if tick()-TT.LastUpdate<TT.UpdateInterval then return end
TT.LastUpdate=tick() TT.Teammates={} TT.Opponents={}
local ct=CC if not ct then return end
local mc=LP.Character if not mc then return end
local mr=mc:FindFirstChild("HumanoidRootPart") if not mr then return end
local np=GNP() if not np then return end
local nz=np.Z local ms=mr.Position.Z<nz and "side1" or "side2"
local fp=ct.FloorPosition local fs=ct.FloorSize
local mnx=fp.X-(fs.X/2) local mxx=fp.X+(fs.X/2) local mnz=fp.Z-(fs.Z/2) local mxz=fp.Z+(fs.Z/2)
for _,p in pairs(Players:GetPlayers()) do
if p~=LP then local ch=p.Character
if ch then local rt=ch:FindFirstChild("HumanoidRootPart")
if rt then local ps=rt.Position
if ps.X>=mnx and ps.X<=mxx and ps.Z>=mnz and ps.Z<=mxz then
local ts=ps.Z<nz and "side1" or "side2"
local v=Vector3.new(0,0,0)
if OH[p.UserId] then local lp=OH[p.UserId].Position local lt=OH[p.UserId].Time local td=tick()-lt if td>0 and td<1 then v=(ps-lp)/td end end
OH[p.UserId]={Position=ps,Time=tick(),Velocity=v}
local pp=ps
if TT.PredictionEnabled and v.Magnitude>0.1 then local pm=1.0 if v.Magnitude>30 then pm=1.5 end pp=ps+(v*TT.PredictionTime*pm) end
local pd={Player=p,Position=ps,PredictedPosition=pp,Velocity=v,Character=ch,Root=rt}
if ts==ms then table.insert(TT.Teammates,pd) else table.insert(TT.Opponents,pd) end
end end end end
end
end

task.spawn(function() while task.wait(0.01) do pcall(UTT) end end)

-- POSITION MARKERS (LEGACY SYSTEM)
local PM,SM={},true

local function CPM(pos,num,col)
local m={}
local s=Instance.new("Part") s.Name="PositionMarker_"..num s.Shape=Enum.PartType.Ball s.Material=Enum.Material.Neon s.Color=col or Color3.fromRGB(0,255,0) s.Transparency=0.3 s.CanCollide=false s.CanTouch=false s.Anchored=true s.Size=Vector3.new(4,4,4) s.CastShadow=false s.Position=pos s.Parent=WS m.Sphere=s
local bg=Instance.new("BillboardGui") bg.Name="NumberLabel" bg.Adornee=s bg.Size=UDim2.new(0,100,0,50) bg.StudsOffset=Vector3.new(0,3,0) bg.AlwaysOnTop=true bg.Parent=s
local tl=Instance.new("TextLabel") tl.Size=UDim2.new(1,0,1,0) tl.BackgroundTransparency=1 tl.Text=tostring(num) tl.TextColor3=Color3.fromRGB(255,255,255) tl.TextScaled=true tl.Font=Enum.Font.GothamBold tl.TextStrokeTransparency=0 tl.Parent=bg m.Label=tl
return m
end

local function ClearPM() for _,m in pairs(PM) do if m.Sphere then m.Sphere:Destroy() end end PM={} end

-- WASD DETECTION
local WK={[Enum.KeyCode.W]=false,[Enum.KeyCode.A]=false,[Enum.KeyCode.S]=false,[Enum.KeyCode.D]=false}
local function IAWH() return WK[Enum.KeyCode.W] or WK[Enum.KeyCode.A] or WK[Enum.KeyCode.S] or WK[Enum.KeyCode.D] end
UIS.InputBegan:Connect(function(i,g) if WK[i.KeyCode]~=nil then WK[i.KeyCode]=true end end)
UIS.InputEnded:Connect(function(i) if WK[i.KeyCode]~=nil then WK[i.KeyCode]=false end end)

local AV={Enabled=false,Beams={},Length=20,Drop=12}

-- DASH DETECTION
local function ISD() local s,r=pcall(function() if GM.MovementHandler and GM.MovementHandler.Instance then return GM.MovementHandler.Instance.DashDirection~=nil end return false end) return s and r or false end

local BLP={LandingPosition=nil,LastUpdate=0,UpdateInterval=0.01,MaxPredictionTime=5.0,Gravity=196.2}
local LastValidLP,LastValidTime=nil,0
if not BLM then BLM={Enabled=false,FloorMarker=nil,TrajectoryLine=nil,UserSetLength=100} end

local function PBL()
if not BD.IsValid or not BD.Position or not BD.Velocity or not CC then return nil end
local bp,bv,gy=BD.Position,BD.Velocity,CC.GroundY
if bp.Y<=gy+1.5 then return Vector3.new(bp.X,gy,bp.Z) end
local a,b,c=0.5*BLP.Gravity,-bv.Y,gy-bp.Y
local disc=b*b-4*a*c
if disc<0 then return nil end
local sd=math.sqrt(disc)
local t1,t2=(-b+sd)/(2*a),(-b-sd)/(2*a)
local t=(t1>0 and t2>0) and math.min(t1,t2) or (t1>0 and t1 or (t2>0 and t2 or nil))
if not t then return nil end
local predT=math.min(t,BLP.MaxPredictionTime)
return Vector3.new(bp.X+bv.X*predT,gy,bp.Z+bv.Z*predT)
end

local function UBLP()
if tick()-BLP.LastUpdate<BLP.UpdateInterval then return end
BLP.LastUpdate=tick()
local newLP=PBL()
if newLP then BLP.LandingPosition=newLP LastValidLP=newLP LastValidTime=tick()
else BLP.LandingPosition=(tick()-LastValidTime<0.2) and LastValidLP or nil end
end
task.spawn(function() while task.wait(0.01) do pcall(UBLP) end end)

local function CBLV()
if BLM.FloorMarker then pcall(function() BLM.FloorMarker:Destroy() end) end
if BLM.TrajectoryLine then pcall(function() BLM.TrajectoryLine:Destroy() end) end
local fm=Instance.new("Part") fm.Name="ENI_Landing_Marker" fm.Shape=Enum.PartType.Cylinder fm.Material=Enum.Material.Neon fm.Color=Color3.fromRGB(0,255,255) fm.Transparency=0 fm.CanCollide=false fm.CanTouch=false fm.Anchored=true fm.Size=Vector3.new(0.5,8,8) fm.Parent=WS BLM.FloorMarker=fm
local tl=Instance.new("Part") tl.Name="ENI_Trajectory_Line" tl.Shape=Enum.PartType.Cylinder tl.Material=Enum.Material.Neon tl.Color=Color3.fromRGB(255,0,255) tl.Transparency=0.4 tl.CanCollide=false tl.CanTouch=false tl.Anchored=true tl.Size=Vector3.new(100,1.2,1.2) tl.Parent=WS BLM.TrajectoryLine=tl
end

local function UBLV()
if not BLM.Enabled then if BLM.FloorMarker and BLM.FloorMarker.Parent then BLM.FloorMarker.Parent=nil BLM.TrajectoryLine.Parent=nil end return end
if not BLM.FloorMarker or not BLM.FloorMarker.Parent then CBLV() end
local lp=BLP.LandingPosition
if lp and BD.IsValid and BD.Position then
BLM.FloorMarker.CFrame=CFrame.new(lp)*CFrame.Angles(0,0,math.rad(90))
BLM.FloorMarker.Parent=WS
local bp=BD.Position
local dist=math.min((bp-lp).Magnitude,BLM.UserSetLength or 100)
local dir=(lp-bp).Unit
local mid=bp+(dir*(dist/2))
BLM.TrajectoryLine.Size=Vector3.new(dist,1.2,1.2)
BLM.TrajectoryLine.CFrame=CFrame.lookAt(mid,mid+dir)*CFrame.Angles(0,math.rad(90),0)
BLM.TrajectoryLine.Parent=WS
else
if BLM.FloorMarker then BLM.FloorMarker.Parent=nil end
if BLM.TrajectoryLine then BLM.TrajectoryLine.Parent=nil end
end
end
task.spawn(function() while task.wait(0.01) do pcall(UBLV) end end)

local function clearav(p)
    if AV.Beams[p] then
        for k,v in pairs(AV.Beams[p]) do
            if typeof(v)=="Instance" then v:Destroy() end
        end
        AV.Beams[p]=nil
    end
end

local function makeav(p)
    if p==LP or not p.Character then return end
    local c=p.Character
    local r=c:FindFirstChild("HumanoidRootPart")
    if not r then return end
    
    clearav(p)
    
    local a0=Instance.new("Attachment",r)
    a0.Position=Vector3.new(0,2,0)
    local a1=Instance.new("Attachment",WS.Terrain)
    local a2=Instance.new("Attachment",WS.Terrain)
    
    local h=Instance.new("Beam")
    h.Attachment0=a0
    h.Attachment1=a1
    h.Width0=0.25
    h.Width1=0.25
    h.LightEmission=1
    h.Brightness=10
    h.Color=ColorSequence.new(Color3.fromRGB(0,255,200))
    h.Parent=r
    
    local v=Instance.new("Beam")
    v.Attachment0=a1
    v.Attachment1=a2
    v.Width0=0.25
    v.Width1=0.25
    v.LightEmission=1
    v.Brightness=10
    v.Color=ColorSequence.new(Color3.fromRGB(255,50,50))
    v.Parent=r
    
    local b=Instance.new("Part")
    b.Shape=Enum.PartType.Ball
    b.Size=Vector3.new(0.6,0.6,0.6)
    b.Anchored=true
    b.CanCollide=false
    b.Material=Enum.Material.Neon
    b.Color=Color3.fromRGB(255,255,0)
    b.Parent=WS
    
    AV.Beams[p]={a0=a0,a1=a1,a2=a2,h=h,v=v,b=b,r=r,c=c}
end

Run.Heartbeat:Connect(function()
    if not AV.Enabled then
        for p,_ in pairs(AV.Beams) do clearav(p) end
        return
    end
    for _,p in ipairs(Players:GetPlayers()) do
        if p==LP then continue end
        if not p.Character then clearav(p) continue end
        if not AV.Beams[p] or AV.Beams[p].c~=p.Character then makeav(p) end
        if not AV.Beams[p] then continue end
        
        local d=AV.Beams[p]
        local cf=d.r.CFrame
        local s=cf.Position+Vector3.new(0,2,0)
        local f=s+cf.LookVector*AV.Length
        local dn=f-Vector3.new(0,AV.Drop,0)
        
        d.a0.WorldPosition=s
        d.a1.WorldPosition=f
        d.a2.WorldPosition=dn
        d.b.Position=f
    end
end)

Players.PlayerRemoving:Connect(clearav)

-- ROTATION HELPER
local function IBOMS()
if not BD.IsValid or not BD.Position then return false end
if not CC then return false end
local np=GNP() if not np then return false end
local ch=LP.Character if not ch then return false end
local rt=ch:FindFirstChild("HumanoidRootPart") if not rt then return false end
local nz=np.Z local mz=rt.Position.Z local bz=BD.Position.Z
local mySide=mz<nz and "side1" or "side2"
local ballSide=bz<nz and "side1" or "side2"
return mySide==ballSide
end

local function ILOMS()
if not BLP.LandingPosition then return false end
if not CC then return false end
local np=GNP() if not np then return false end
local ch=LP.Character if not ch then return false end
local rt=ch:FindFirstChild("HumanoidRootPart") if not rt then return false end
local nz=np.Z local mz=rt.Position.Z local lz=BLP.LandingPosition.Z
local mySide=mz<nz and "side1" or "side2"
local landingSide=lz<nz and "side1" or "side2"
return mySide==landingSide
end

-- POSITION ROTATION HELPERS
local PR={CurrentIndex=1,Mode="Cycle"}

local function GPC() if not CC then return 0 end local cid=CC.Id local pos=SP[cid] if not pos then return 0 end return #pos end
local function COD(pos) if #TT.Opponents==0 then return math.huge end local md=math.huge for _,opp in ipairs(TT.Opponents) do local op=TT.PredictionEnabled and opp.PredictedPosition or opp.Position local p2=Vector3.new(pos.X,0,pos.Z) local o2=Vector3.new(op.X,0,op.Z) local d=(p2-o2).Magnitude md=math.min(md,d) end return md end
local function GSP() if not CC then return nil end local cid=CC.Id local pos=SP[cid] if not pos or #pos==0 then return nil end local bp,bd=nil,-math.huge for _,p in ipairs(pos) do local vp=Vector3.new(p.X,p.Y,p.Z) local d=COD(vp) if d>bd then bd=d bp=vp end end return bp end
local function GNCP() if not CC then return nil end local cid=CC.Id local pos=SP[cid] if not pos or #pos==0 then return nil end if PR.CurrentIndex>#pos then PR.CurrentIndex=1 end local p=pos[PR.CurrentIndex] return Vector3.new(p.X,p.Y,p.Z) end
local function GRP() if not CC then return nil end local cid=CC.Id local pos=SP[cid] if not pos or #pos==0 then return nil end local ri=math.random(1,#pos) local p=pos[ri] return Vector3.new(p.X,p.Y,p.Z) end
local function GCPB() if not CC or not BD.IsValid or not BD.Position then return nil end local cid=CC.Id local pos=SP[cid] if not pos or #pos==0 then return nil end local bp=BD.Position local cp,md=nil,math.huge for _,p in ipairs(pos) do local vp=Vector3.new(p.X,p.Y,p.Z) local d=(vp-bp).Magnitude if d<md then md=d cp=vp end end return cp end
local function IPI() local c=GPC() if c>0 then PR.CurrentIndex+=1 if PR.CurrentIndex>c then PR.CurrentIndex=1 end end end

print("━━━ END OF PART 1/3 ━━━")

--   v14.7 - PART 2/3 (MIDDLE SECTION)
-- Opponent Detection + Boundaries + Movement Stats (Debuff-Aware) + Rotation

-- OPPONENT DETECTION
local OPD={Enabled=false,MinSafeDistance=15,CurrentBestPosition=nil,LastUpdate=0,UpdateInterval=0.01,Connection=nil}

local function OPDL() if not OPD.Enabled then return end if tick()-OPD.LastUpdate<OPD.UpdateInterval then return end OPD.LastUpdate=tick() if not CC then return end local sp=GSP() if sp then OPD.CurrentBestPosition=sp end end
local function SOPD(en) OPD.Enabled=en if OPD.Connection then OPD.Connection:Disconnect() OPD.Connection=nil end if en then OPD.Connection=Run.RenderStepped:Connect(function() pcall(OPDL) end) end end

local function UPM()
if not SM then ClearPM() return end
if not CC then ClearPM() return end
local cid=CC.Id local pos=SP[cid] if not pos or #pos==0 then ClearPM() return end
ClearPM()
for i,p in ipairs(pos) do
local vp=Vector3.new(p.X,p.Y,p.Z)
local isf=OPD.Enabled and OPD.CurrentBestPosition and (OPD.CurrentBestPosition-vp).Magnitude<0.1
local col=isf and Color3.fromRGB(0,255,0) or Color3.fromRGB(255,165,0)
local m=CPM(vp,i,col) table.insert(PM,m)
end
end

-- MAX DISTANCE BOUNDARY
local MDB={Enabled=false,BoundaryZ=nil,IsSelecting=false,SelectionConnection=nil,VisualizerPart=nil}

function ILIB()
if not MDB.Enabled or not MDB.BoundaryZ then return true end
if not BD.IsValid or not BD.Position then return false end
local ballZ=BD.Position.Z
local ch=LP.Character if not ch then return false end
local rt=ch:FindFirstChild("HumanoidRootPart") if not rt then return false end
local np=GNP() if not np then return true end
local mz=rt.Position.Z local nz=np.Z local bz=MDB.BoundaryZ
if mz<nz then return ballZ>bz and ballZ<nz else return ballZ>nz and ballZ<bz end
end

function CRBV(zp)
if MDB.VisualizerPart then pcall(function() MDB.VisualizerPart:Destroy() end) MDB.VisualizerPart=nil end
if not CC then return end
local cp=CC.FloorPosition local cs=CC.FloorSize local gy=CC.GroundY
local v=Instance.new("Part") v.Name="MaxDistanceBoundary" v.Shape=Enum.PartType.Block v.Material=Enum.Material.Neon v.Transparency=0.3 v.CanCollide=false v.CanTouch=false v.Anchored=true v.CastShadow=false
local lw=cs.X+20 local lh=0.5 local lt=0.5
v.Size=Vector3.new(lw,lh,lt)
v.Position=Vector3.new(cp.X,gy+0.3,zp)
v.Color=Color3.fromRGB(0,255,0)
v.Parent=WS MDB.VisualizerPart=v
end

local function SSBS()
if not CC then Notify("Boundary","No court detected") return end
MDB.IsSelecting=true
Notify("Boundary","Click floor to set boundary")
if MDB.SelectionConnection then MDB.SelectionConnection:Disconnect() end
MDB.SelectionConnection=UIS.InputBegan:Connect(function(i,g)
if g then return end
if not MDB.IsSelecting then return end
if i.UserInputType==Enum.UserInputType.MouseButton1 then
local mp=UIS:GetMouseLocation() local r=Cam:ViewportPointToRay(mp.X,mp.Y)
local rp=RaycastParams.new() rp.FilterType=Enum.RaycastFilterType.Whitelist rp.FilterDescendantsInstances={CC.Floor}
local res=WS:Raycast(r.Origin,r.Direction*1000,rp)
if res then
local p=res.Position MDB.BoundaryZ=p.Z MDB.Enabled=true MDB.IsSelecting=false
local cid=CC.Id SBC(cid,p.Z) CRBV(p.Z)
Notify("Boundary","Set at Z="..math.floor(p.Z))
if MDB.SelectionConnection then MDB.SelectionConnection:Disconnect() MDB.SelectionConnection=nil end
end
end
end)
end

local function CLB()
MDB.Enabled=false MDB.BoundaryZ=nil
if MDB.VisualizerPart then pcall(function() MDB.VisualizerPart:Destroy() end) MDB.VisualizerPart=nil end
if MDB.SelectionConnection then MDB.SelectionConnection:Disconnect() MDB.SelectionConnection=nil end
MDB.IsSelecting=false
if CC then local cid=CC.Id SBC(cid,nil) end
Notify("Boundary","Cleared")
end

-- ROTATION TO TARGET
local function RMTT(useLanding, offset, ignoreOppSide)
local char=LP.Character if not char then return false end
local root=char:FindFirstChild("HumanoidRootPart") if not root then return false end
if not BD.IsValid or not BD.Position then return false end
local ballPos=BD.Position
local landingPos=BLP.LandingPosition
local targetPos=ballPos
offset=math.clamp(offset,0,30)
if useLanding then
if landingPos and (ILOMS() or ignoreOppSide) then
local t=offset/30
targetPos=ballPos:Lerp(landingPos,t)
elseif IBOMS() or ignoreOppSide then
targetPos=ballPos
else
return false
end
else
if IBOMS() or ignoreOppSide then
targetPos=ballPos
if offset>0 and BD.Velocity and BD.Velocity.Magnitude>1 then
local ballDir=Vector3.new(BD.Velocity.X,0,BD.Velocity.Z).Unit
targetPos=ballPos+(ballDir*offset)
end
else
return false
end
end
local playerPos=root.Position
local aimDirection=(targetPos-playerPos)*Vector3.new(1,0,1)
if aimDirection.Magnitude<0.1 then return false end
root.CFrame=CFrame.lookAt(playerPos,playerPos+aimDirection)
return true
end

-- MANUAL ROTATION (Q KEY)
local MR={Enabled=false,UseLandingSpot=false,BallOffsetDistance=0,IgnoreOppSide=false,LastManualUse=0}

local function EMR()
if not MR.Enabled then return false end
if IAWH() then return false end
if ISD() then return false end
local s=RMTT(MR.UseLandingSpot,MR.BallOffsetDistance,MR.IgnoreOppSide)
if s then MR.LastManualUse=tick() end
return s
end

UIS.InputBegan:Connect(function(i,g) if g then return end if i.KeyCode==Enum.KeyCode.Q then EMR() end end)

-- AUTO ROTATION + DASH (IMPROVED NET CROSSING DETECTION)
local ARD={Enabled=false,ToggleKey=Enum.KeyCode.Five,LastBallSide=nil,HasRotatedForCross=false,HasDashedForCross=false,CrossDetectionCooldown=0.3,LastCrossTime=0,UseLandingForRotation=true,BallOffsetDistance=0,ActivationDelay=0,LastDetectionTime=0,Stats={TotalRotations=0,TotalDashes=0,TotalCrosses=0,LastRotationTime=0,LastDashTime=0,LastCrossTime=0}}
local function DBCMS()
if not ARD.Enabled then return end
if IAWH() then return end
if ISD() then return end
local trackPos
if ARD.UseLandingForRotation and BLP.LandingPosition then
trackPos=BLP.LandingPosition
elseif BD.IsValid and BD.Position then
trackPos=BD.Position
else
return
end
if not CC then return end
local ch=LP.Character if not ch then return end
local rt=ch:FindFirstChild("HumanoidRootPart") if not rt then return end
local np=GNP() if not np then return end
local nz=np.Z local mz=rt.Position.Z local dz=trackPos.Z
local ms=mz<nz and "side1" or "side2"
local bs=dz<nz and "side1" or "side2"
if ARD.LastBallSide==nil then ARD.LastBallSide=bs return end
if ARD.LastBallSide~=ms and bs==ms then
local ts=tick()-ARD.LastCrossTime
if ts>=ARD.CrossDetectionCooldown then
ARD.LastDetectionTime=tick()
task.delay(ARD.ActivationDelay,function()
if not ARD.HasRotatedForCross then
if IAWH() or ISD() then return end
if ARD.UseLandingForRotation then
if not ILOMS() then return end
else
if not IBOMS() then return end
end
local s=RMTT(ARD.UseLandingForRotation,ARD.BallOffsetDistance,false)
if s then
ARD.HasRotatedForCross=true
ARD.Stats.TotalRotations+=1
ARD.Stats.LastRotationTime=tick()
if not ARD.HasDashedForCross then
task.spawn(function()
pcall(function()
VIM:SendKeyEvent(true,Enum.KeyCode.Q,false,game)
task.wait(0.05)
VIM:SendKeyEvent(false,Enum.KeyCode.Q,false,game)
end)
end)
ARD.HasDashedForCross=true
ARD.Stats.TotalDashes+=1
ARD.Stats.LastDashTime=tick()
end
end
end
end)
ARD.LastCrossTime=tick()
ARD.Stats.TotalCrosses+=1
ARD.Stats.LastCrossTime=tick()
end
end
if bs~=ms then
ARD.HasRotatedForCross=false
ARD.HasDashedForCross=false
end
ARD.LastBallSide=bs
end

task.spawn(function() while task.wait(0.005) do pcall(DBCMS) end end)

UIS.InputBegan:Connect(function(i,g) if g then return end if i.KeyCode==ARD.ToggleKey then ARD.Enabled=not ARD.Enabled ARD.LastBallSide=nil ARD.HasRotatedForCross=false ARD.HasDashedForCross=false Notify("Auto Rotation + Dash",ARD.Enabled and "Enabled" or "Disabled") end end)

-- BALL BOUNDS & POSITION HELPERS
local function IBIB()
if not BD.IsValid or not BD.Position then return false end
if not CC then return false end
local bp=BD.Position local cp=CC.FloorPosition local cs=CC.FloorSize local tol=15
local mnx=cp.X-(cs.X/2)-tol local mxx=cp.X+(cs.X/2)+tol local mnz=cp.Z-(cs.Z/2)-tol local mxz=cp.Z+(cs.Z/2)+tol
return bp.X>=mnx and bp.X<=mxx and bp.Z>=mnz and bp.Z<=mxz
end

local function IPOS(pos)
if not CC or not pos then return true end
local np=GNP() if not np then return true end
local ch=LP.Character if not ch then return true end
local rt=ch:FindFirstChild("HumanoidRootPart") if not rt then return true end
local nz=np.Z local mz=rt.Position.Z local pz=pos.Z
local ms=mz<nz and "side1" or "side2" local ps=pz<nz and "side1" or "side2"
return ms~=ps
end

local function IBOS() if not BD.IsValid or not BD.Position then return true end return IPOS(BD.Position) end

local function MPAN(pos)
local np=GNP() if not np then return pos end
local nz=np.Z local off=pos.Z-nz local nwz=nz-off
return Vector3.new(pos.X,pos.Y,nwz)
end

local function MBAN(bz)
local np=GNP() if not np then return bz end
local ch=LP.Character if not ch then return bz end
local rt=ch:FindFirstChild("HumanoidRootPart") if not rt then return bz end
local nz=np.Z local mz=rt.Position.Z local co=math.abs(bz-nz)
if mz<nz then return nz-co else return nz+co end
end

local function MSP()
if not CC then return end
local cid=CC.Id if not SP[cid] or #SP[cid]==0 then return end
local np={}
for _,p in ipairs(SP[cid]) do local vp=Vector3.new(p.X,p.Y,p.Z) local m=MPAN(vp) table.insert(np,{X=m.X,Y=m.Y,Z=m.Z}) end
SP[cid]=np SPC(cid,np)
if SB[cid] then local nbz=MBAN(SB[cid]) SB[cid]=nbz SBC(cid,nbz) end
UPM() Notify("Positions","Switched Sides")
end

-- AUTO SWITCH POSITIONS
local ASP={Enabled=false,LastSide=nil,Cooldown=2,LastSwitch=0}

local function DAS()
if not ASP.Enabled then return end
if not CC then return end
if tick()-ASP.LastSwitch<ASP.Cooldown then return end
local ch=LP.Character if not ch then return end
local rt=ch:FindFirstChild("HumanoidRootPart") if not rt then return end
local np=GNP() if not np then return end
local mz=rt.Position.Z local nz=np.Z
local cs=mz<nz and "side1" or "side2"
if ASP.LastSide==nil then ASP.LastSide=cs return end
if cs~=ASP.LastSide then MSP() ASP.LastSide=cs ASP.LastSwitch=tick() end
end

task.spawn(function() while task.wait(0.5) do pcall(DAS) end end)

UIS.InputBegan:Connect(function(i,g) if g then return end if i.KeyCode==Enum.KeyCode.LeftControl then MSP() end end)

-- POSITION SELECTION
local PS={Enabled=false,SelectedCount=1,CurrentPositions={},IsSelecting=false,SelectionConnection=nil}

local function SPSel(cnt)
if not CC then Notify("Position Selection","No court detected") return end
PS.SelectedCount=cnt PS.CurrentPositions={} PS.IsSelecting=true ClearPM()
Notify("Position Selection","Click "..cnt.." spot(s) on floor")
if PS.SelectionConnection then PS.SelectionConnection:Disconnect() end
PS.SelectionConnection=UIS.InputBegan:Connect(function(i,g)
if g then return end
if not PS.IsSelecting then return end
if i.UserInputType==Enum.UserInputType.MouseButton1 then
local mp=UIS:GetMouseLocation() local r=Cam:ViewportPointToRay(mp.X,mp.Y)
local rp=RaycastParams.new() rp.FilterType=Enum.RaycastFilterType.Whitelist rp.FilterDescendantsInstances={CC.Floor}
local res=WS:Raycast(r.Origin,r.Direction*1000,rp)
if res then
local p=res.Position table.insert(PS.CurrentPositions,{X=p.X,Y=p.Y,Z=p.Z})
local n=#PS.CurrentPositions local m=CPM(p,n,Color3.fromRGB(255,165,0)) table.insert(PM,m)
Notify("Position "..n,"Placed")
if #PS.CurrentPositions>=PS.SelectedCount then
PS.IsSelecting=false
if PS.SelectionConnection then PS.SelectionConnection:Disconnect() PS.SelectionConnection=nil end
local cid=CC.Id SPC(cid,PS.CurrentPositions) PR.CurrentIndex=1 UPM()
Notify("Positions","Saved "..#PS.CurrentPositions.." positions")
end
end
end
end)
end

-- COURT CHANGE DETECTION (WITH BOUNDARY AUTO-LOAD)
local function OCJ(cid)
local pos=SP[cid]
if pos and #pos>0 then PR.CurrentIndex=1 UPM() if OPD.Enabled then OPDL() end end
ARD.LastBallSide=nil
pcall(function()
if MDB and SB and SB[cid] then
MDB.BoundaryZ=SB[cid]
MDB.Enabled=true
CRBV(SB[cid])
end
end)
end

local lcc=0
Run.Heartbeat:Connect(function()
if tick()-lcc>1 then lcc=tick()
local nc=GetPlayerCourt()
if nc and (not CC or nc.Id~=CC.Id) then CC=nc OCJ(nc.Id)
elseif not nc and CC then CC=nil ClearPM() if MDB and MDB.VisualizerPart then MDB.VisualizerPart:Destroy() MDB.VisualizerPart=nil end
else CC=nc end
end
end)

-- BOUNDARY VISUALIZER UPDATE
Run.RenderStepped:Connect(function()
pcall(function()
if not CC then if MDB and MDB.VisualizerPart and MDB.VisualizerPart.Parent then MDB.VisualizerPart.Parent=nil end return end
if MDB and MDB.Enabled and MDB.VisualizerPart and MDB.BoundaryZ and MDB.VisualizerPart.Parent then
local iib=ILIB()
MDB.VisualizerPart.Color=iib and Color3.fromRGB(0,255,0) or Color3.fromRGB(255,0,0)
local gy=CC.GroundY
MDB.VisualizerPart.Position=Vector3.new(MDB.VisualizerPart.Position.X,gy+0.3,MDB.BoundaryZ)
elseif MDB and MDB.VisualizerPart and MDB.VisualizerPart.Parent then MDB.VisualizerPart.Parent=nil end
end)
end)

-- STATS MODIFICATION
local Stats={Enabled=false,Values={DashDistance=25,Reach=14,HitSpeed=1,Speed=16}}
local OGSF=nil

task.spawn(function()
repeat Run.Heartbeat:Wait() until ML
if not GM.RacketStatUtils then return end
OGSF=GM.RacketStatUtils.GetStatForPlayer
GM.RacketStatUtils.GetStatForPlayer=function(pc,sn)
local ov=OGSF(pc,sn)
if Stats.Enabled and pc==GM.PlayerControl then
if sn=="DashDistance" then return Stats.Values.DashDistance
elseif sn=="Reach" then return Stats.Values.Reach
elseif sn=="HitSpeed" then return Stats.Values.HitSpeed
end
end
return ov
end
end)

local function ASD()
if not Stats.Enabled then return end
pcall(function() if GM.MovementHandler and GM.MovementHandler.Instance then GM.MovementHandler.Instance.DashDistance=Stats.Values.DashDistance*1.6 end end)
end

task.spawn(function() while task.wait(1) do if Stats.Enabled then ASD() end end end)

-- MOVEMENT STATS (COMPLETELY REWRITTEN - INSTANT PERSISTENCE + DEBUFF RESPECT)
local MS={Enabled=false,WalkSpeed=35,JumpPower=50,DebuffActive=false,LastDebuffCheck=0,DebuffCheckInterval=0.05,CustomValuesApplied=false}
local DSS={Speed=20,Active=false,Conn=nil}
local GS={Gravity=0.7,Conn=nil}

local function CDDA()
if not MS.Enabled then return false end
if tick()-MS.LastDebuffCheck<MS.DebuffCheckInterval then return MS.DebuffActive end
MS.LastDebuffCheck=tick()
local debuffDetected=false
pcall(function()
local ch=LP.Character
if ch then
local h=ch:FindFirstChild("Humanoid")
if h then
local currentWS=h.WalkSpeed
local currentJP=h.JumpPower
if currentWS<(MS.WalkSpeed*0.85) or currentJP<(MS.JumpPower*0.85) then
debuffDetected=true
end
end
end
if GM.MovementHandler and GM.MovementHandler.Instance then
local mh=GM.MovementHandler.Instance
if mh.RunSpeed and mh.RunSpeed<(MS.WalkSpeed*0.85) then
debuffDetected=true
end
if mh.JumpPower and mh.JumpPower<(MS.JumpPower*0.85) then
debuffDetected=true
end
end
end)
MS.DebuffActive=debuffDetected
return debuffDetected
end

local function EMV()
if not MS.Enabled then return end
if CDDA() then return end
pcall(function()
if GM.MovementHandler and GM.MovementHandler.Instance then
GM.MovementHandler.Instance.RunSpeed=MS.WalkSpeed
GM.MovementHandler.Instance.JumpPower=MS.JumpPower
end
local ch=LP.Character
if ch then
local h=ch:FindFirstChild("Humanoid")
if h then
h.WalkSpeed=MS.WalkSpeed
h.JumpPower=MS.JumpPower
end
end
MS.CustomValuesApplied=true
end)
end

local function startdash()
    if DSS.Conn then DSS.Conn:Disconnect() DSS.Conn=nil end
    DSS.Conn=Run.RenderStepped:Connect(function()
        if not LP.Character then return end
        local hum=LP.Character:FindFirstChild("Humanoid")
        if not hum then return end
        -- anti fling - dont boost if ragdolled or flinging
        local state=hum:GetState()
        if state==Enum.HumanoidStateType.Ragdoll or state==Enum.HumanoidStateType.FallingDown then return end
        if hum.Sit then return end
        
        local root=LP.Character:FindFirstChild("HumanoidRootPart")
        if not root then return end
        
        -- anti fling - cap max velocity
        local vel=root.AssemblyLinearVelocity
        if vel.Magnitude>150 then return end
        
        local mult=DSS.Speed/10
        local bv=root:FindFirstChild("BodyVelocity")
        if bv and bv.MaxForce.Magnitude>0 then
            local v=bv.Velocity
            -- only boost if reasonable speed (not flinging)
            if v.Magnitude>1 and v.Magnitude<80 then 
                bv.Velocity=v*mult 
            end
        end
        
        local bp=root:FindFirstChild("BodyPosition")
        if bp and bp.MaxForce.Magnitude>0 then
            if bp.P==10000 then bp.P=bp.P*mult end
        end
    end)
end

local function hookgrav()
    task.spawn(function()
        while not LP.Character do task.wait() end
        local root=LP.Character:WaitForChild("HumanoidRootPart",5)
        if not root then return end
        local bf=root:WaitForChild("BodyForce",3)
        if not bf then return end
        
        local mt=getrawmetatable(bf)
        local old=mt.__newindex
        setreadonly(mt,false)
        
        mt.__newindex=newcclosure(function(t,k,v)
            if t==bf and k=="Force" and typeof(v)=="Vector3" then
                if v.Y>0 and math.abs(v.X)<0.01 and math.abs(v.Z)<0.01 then
                    -- only apply when falling AND not grounded AND not ragdolled
                    if root and root.AssemblyLinearVelocity.Y<0 then
                        local hum=LP.Character and LP.Character:FindFirstChild("Humanoid")
                        if hum and hum.FloorMaterial==Enum.Material.Air then
                            local state=hum:GetState()
                            if state~=Enum.HumanoidStateType.Ragdoll and state~=Enum.HumanoidStateType.FallingDown then
                                v=Vector3.new(0,v.Y*(0.7/GS.Gravity),0)
                            end
                        end
                    end
                end
            end
            return old(t,k,v)
        end)
        
        setreadonly(mt,true)
    end)
end

task.spawn(function() while task.wait(0.02) do EMV() end end)

-- INSTANT CHARGE
local ICS={Enabled=false,CustomDuration=0.001}
local OCD=1

task.spawn(function() repeat Run.Heartbeat:Wait() until ML pcall(function() if GM.SharedData and GM.SharedData.GAME then OCD=GM.SharedData.GAME.SWING_CHARGE_DURATION or 1 end end) end)

local function SICD(d)
ICS.CustomDuration=tonumber(d) or 0.001
if ICS.Enabled and GM.SharedData and GM.SharedData.GAME then GM.SharedData.GAME.SWING_CHARGE_DURATION=ICS.CustomDuration end
end

local function STIC(en)
ICS.Enabled=en
if en then if GM.SharedData and GM.SharedData.GAME then GM.SharedData.GAME.SWING_CHARGE_DURATION=ICS.CustomDuration end else if GM.SharedData and GM.SharedData.GAME then GM.SharedData.GAME.SWING_CHARGE_DURATION=OCD end end
end

task.spawn(function() while task.wait(0.5) do if ICS.Enabled and GM.SharedData and GM.SharedData.GAME then GM.SharedData.GAME.SWING_CHARGE_DURATION=ICS.CustomDuration end end end)

-- COOLDOWN DETECTION (SET BUTTON)
local SBS={OnCooldown=false,CooldownEndTime=0,LastGUICheck=0,GUICheckInterval=0.03,LastSetUse=0,SetDebounce=0.3}

local function CSBG()
local s,r=pcall(function()
local pg=LP:FindFirstChild("PlayerGui") if not pg then return false end
local gb=pg:FindFirstChild("GAMEPLAYBUTTONS") if not gb then return false end
local h=gb:FindFirstChild("GameplayButtonHandler") if not h then return false end
local sb=h:FindFirstChild("SetButton") if not sb then return false end
local cp=sb:FindFirstChild("CircularProgressCooldown") if not cp then return false end
local o=cp:FindFirstChild("Object") if not o then return false end
if o.Visible==true then return true end
local cl=o:FindFirstChild("CooldownLabel") if cl then local t=cl.Text if t and t~="" then local n=tonumber(t) if n and n>0 then return true end end end
return false
end)
return s and r or false
end

local function ISOC()
if SBS.OnCooldown and tick()<SBS.CooldownEndTime then return true end
if tick()-SBS.LastGUICheck>SBS.GUICheckInterval then SBS.LastGUICheck=tick() local gcd=CSBG() if gcd then SBS.OnCooldown=true SBS.CooldownEndTime=tick()+1 end return gcd end
return false
end

task.spawn(function() while task.wait(0.03) do pcall(ISOC) end end)

task.spawn(function()
repeat Run.Heartbeat:Wait() until ML and LP.Character
pcall(function()
if GM.Actions and GM.Actions.RACKET_COOLDOWN_MOVE then
GM.Actions.RACKET_COOLDOWN_MOVE:Connect(function(mt,ct)
pcall(function()
if GM.SharedData and GM.SharedData.GAME then
if mt==GM.SharedData.GAME.RACKET_ENUMS.Set then
if ct==0 then SBS.OnCooldown=false SBS.CooldownEndTime=0 else SBS.OnCooldown=true SBS.CooldownEndTime=tick()+ct SBS.LastSetUse=tick() end
end
end
end)
end)
end
if GM.Actions and GM.Actions.USE_SET then GM.Actions.USE_SET:Connect(function() SBS.LastSetUse=tick() end) end
end)
end)

-- COOLDOWN DETECTION (ABILITY BUTTON)
local ABD={OnCooldown=false,ButtonInstance=nil}

local function FAB()
local s,r=pcall(function()
local pg=LP:WaitForChild("PlayerGui",5) if not pg then return nil end
local gb=pg:FindFirstChild("GAMEPLAYBUTTONS") if not gb then return nil end
local h=gb:FindFirstChild("GameplayButtonHandler") if not h then return nil end
local abc=h:FindFirstChild("ActionButtonClass") if not abc then return nil end
local ab=abc:FindFirstChild("AbilityButton") if not ab then return nil end
return ab
end)
if s and r then ABD.ButtonInstance=r return r end
return nil
end

local function IAOC()
if not ABD.ButtonInstance then FAB() end
if not ABD.ButtonInstance then return false end
local s,ioc=pcall(function()
local cp=ABD.ButtonInstance:FindFirstChild("CircularProgress") if cp then local o=cp:FindFirstChild("Object") if o then return o.Visible==true end end
return false
end)
if s then ABD.OnCooldown=ioc return ioc end
return false
end

-- NO DASH COOLDOWN
local NDC,NDCC=false,nil

local function STNDC(en)
if NDCC then NDCC:Disconnect() end
NDC=en
if en then
pcall(function() if GM.SharedData and GM.SharedData.GAME then GM.SharedData.GAME.DASH_COOLDOWN=0 end end)
pcall(function()
if GM.MovementHandler and GM.MovementHandler.Instance then
NDCC=Run.Heartbeat:Connect(function()
if not NDC then return end
local m=GM.MovementHandler.Instance
if m then
m.DashCooldown=0
m.DashUsed=0
m.CanDash=true
m.DashTick=0
if not m.DashDirection then m.IsDashing=false end
if m._dashResetTask then pcall(function() task.cancel(m._dashResetTask) m._dashResetTask=nil end) end
if not m.DashDirection and m.DashUsed>0 then m.DashUsed=0 end
end
end)
end
end)
Notify("No Dash CD","Enabled")
else
pcall(function() if GM.SharedData and GM.SharedData.GAME then GM.SharedData.GAME.DASH_COOLDOWN=OV.DashCooldown end end)
Notify("No Dash CD","Disabled")
end
end

print("━━━ END OF PART 2/3 ━━━")

--   v14.7 - PART 3/3 (FINAL SECTION)
-- Auto Pass + Aimbot + Effects + Auto Swing + Auto Abilities + UI Population

-- AUTO PASS (COMPLETELY REWRITTEN - FRESH TEAMMATE DETECTION)
local AP={Active=false,ActivationTime=0,Timeout=2,StandingHeight=0,JumpingHeight=0,LineLength=15,ActivationKey=Enum.KeyCode.P,TargetTeammate=nil,SidewaysEndpoint=nil,IsTeammateBehind=false,IsTeammateAligned=false,StraightLine=nil,HorizontalLine=nil,VerticalLine=nil,EndpointMarker=nil,LineAlwaysVisible=true,Stats={TotalPasses=0},HasNotifiedTimeout=false,AlignmentThreshold=8}

local function IsJumping()
local ch=LP.Character if not ch then return false end
local h=ch:FindFirstChild("Humanoid") if not h then return false end
local state=h:GetState()
return state==Enum.HumanoidStateType.Jumping or state==Enum.HumanoidStateType.Freefall
end

local function GetBestTeammate()
if #TT.Teammates==0 then return nil end
local ch=LP.Character if not ch then return nil end
local rt=ch:FindFirstChild("HumanoidRootPart") if not rt then return nil end
local mp=rt.Position
if not CC then return nil end
local np,ns=GNP() if not np then return nil end
local nz=np.Z local mz=rt.Position.Z
local closest=nil local minDist=math.huge
for _,tm in ipairs(TT.Teammates) do
local tpos=tm.Position local tmz=tpos.Z
local tmSide=tmz<nz and "side1" or "side2"
local mySide=mz<nz and "side1" or "side2"
if tmSide==mySide then local dist=(tpos-mp).Magnitude if dist>5 and dist<minDist then minDist=dist closest=tm end end
end
return closest
end

local function IsTeammateBehindOrAligned(teammate)
if not teammate or not CC then return false,false end
local np,ns=GNP() if not np then return false,false end
local ch=LP.Character if not ch then return false,false end
local rt=ch:FindFirstChild("HumanoidRootPart") if not rt then return false,false end
local nz=np.Z local mz=rt.Position.Z local tz=teammate.Position.Z
local mySide=mz<nz and "side1" or "side2"
local isBehind=false
if mySide=="side1" then isBehind=tz<mz else isBehind=tz>mz end
local zDiff=math.abs(tz-mz)
local isAligned=zDiff<AP.AlignmentThreshold
return isBehind,isAligned
end

local function CalculateSidewaysEndpoint(myPos,teammatePos)
if not CC then return nil end
local np,ns=GNP() if not np then return nil end
local direction=math.sign(teammatePos.X-myPos.X)
if direction==0 then local nz=np.Z local mz=myPos.Z if mz<nz then direction=1 else direction=-1 end end
local endpointX=myPos.X+(direction*AP.LineLength)
local cp=CC.FloorPosition local cs=CC.FloorSize local margin=10
endpointX=math.clamp(endpointX,cp.X-(cs.X/2)+margin,cp.X+(cs.X/2)-margin)
local endpointZ=myPos.Z
local nz=np.Z local mz=myPos.Z
if mz<nz then endpointZ=math.min(endpointZ,nz-5) else endpointZ=math.max(endpointZ,nz+5) end
return Vector3.new(endpointX,myPos.Y,endpointZ)
end

local function UpdatePassLineVisual()
local tm=GetBestTeammate()
if not tm then
if AP.StraightLine and AP.StraightLine.Parent then AP.StraightLine.Parent=nil end
if AP.HorizontalLine and AP.HorizontalLine.Parent then AP.HorizontalLine.Parent=nil AP.VerticalLine.Parent=nil AP.EndpointMarker.Parent=nil end
AP.TargetTeammate=nil AP.SidewaysEndpoint=nil AP.IsTeammateBehind=false AP.IsTeammateAligned=false
return
end
local ch=LP.Character if not ch then return end
local rt=ch:FindFirstChild("HumanoidRootPart") if not rt then return end
local myPos=rt.Position
local isBehind,isAligned=IsTeammateBehindOrAligned(tm)
AP.IsTeammateBehind=isBehind AP.IsTeammateAligned=isAligned AP.TargetTeammate=tm
local useSideways=isBehind or isAligned
if useSideways then
if AP.StraightLine and AP.StraightLine.Parent then AP.StraightLine.Parent=nil end
local endpoint=CalculateSidewaysEndpoint(myPos,tm.Position)
if not endpoint then return end
AP.SidewaysEndpoint=endpoint
if not AP.HorizontalLine then
local hl=Instance.new("Part") hl.Name="APHorizontalLine" hl.Shape=Enum.PartType.Cylinder hl.Material=Enum.Material.Neon hl.Color=Color3.fromRGB(0,255,255) hl.Transparency=0.4 hl.CanCollide=false hl.CanTouch=false hl.Anchored=true hl.CastShadow=false AP.HorizontalLine=hl
local vl=Instance.new("Part") vl.Name="APVerticalLine" vl.Shape=Enum.PartType.Cylinder vl.Material=Enum.Material.Neon vl.Color=Color3.fromRGB(0,255,255) vl.Transparency=0.4 vl.CanCollide=false vl.CanTouch=false vl.Anchored=true vl.CastShadow=false AP.VerticalLine=vl
local em=Instance.new("Part") em.Name="APEndpointMarker" em.Shape=Enum.PartType.Ball em.Material=Enum.Material.Neon em.Color=Color3.fromRGB(255,0,0) em.Transparency=0.3 em.CanCollide=false em.CanTouch=false em.Anchored=true em.Size=Vector3.new(3,3,3) em.CastShadow=false AP.EndpointMarker=em
end
local hDist=(endpoint-myPos).Magnitude local hMid=myPos+(endpoint-myPos)/2
AP.HorizontalLine.Size=Vector3.new(hDist,0.8,0.8) AP.HorizontalLine.CFrame=CFrame.lookAt(hMid,endpoint)*CFrame.Angles(0,math.rad(90),0)
local tmHead=tm.Character:FindFirstChild("Head")
if tmHead then local vDist=(tmHead.Position-endpoint).Magnitude local vMid=endpoint+(tmHead.Position-endpoint)/2 AP.VerticalLine.Size=Vector3.new(vDist,0.5,0.5) AP.VerticalLine.CFrame=CFrame.lookAt(vMid,tmHead.Position)*CFrame.Angles(0,math.rad(90),0) end
AP.EndpointMarker.Position=endpoint
local col=AP.Active and Color3.fromRGB(0,255,0) or Color3.fromRGB(0,255,255)
AP.HorizontalLine.Color=col AP.VerticalLine.Color=col
AP.HorizontalLine.Parent=WS AP.VerticalLine.Parent=WS AP.EndpointMarker.Parent=WS
else
if AP.HorizontalLine and AP.HorizontalLine.Parent then AP.HorizontalLine.Parent=nil AP.VerticalLine.Parent=nil AP.EndpointMarker.Parent=nil end
AP.SidewaysEndpoint=nil
local tmHead=tm.Character:FindFirstChild("Head")
if tmHead then
if not AP.StraightLine then local sl=Instance.new("Part") sl.Name="APStraightLine" sl.Shape=Enum.PartType.Cylinder sl.Material=Enum.Material.Neon sl.Color=Color3.fromRGB(0,255,255) sl.Transparency=0.4 sl.CanCollide=false sl.CanTouch=false sl.Anchored=true sl.CastShadow=false AP.StraightLine=sl end
local dist=math.min((tmHead.Position-myPos).Magnitude,AP.LineLength)
local dir=(tmHead.Position-myPos).Unit
local endPoint=myPos+(dir*dist)
local mid=myPos+(endPoint-myPos)/2
AP.StraightLine.Size=Vector3.new(dist,0.8,0.8)
AP.StraightLine.CFrame=CFrame.lookAt(mid,endPoint)*CFrame.Angles(0,math.rad(90),0)
AP.StraightLine.Color=AP.Active and Color3.fromRGB(0,255,0) or Color3.fromRGB(0,255,255)
AP.StraightLine.Parent=WS
else if AP.StraightLine and AP.StraightLine.Parent then AP.StraightLine.Parent=nil end end
end
end

Run.RenderStepped:Connect(function() if AP.LineAlwaysVisible or AP.Active then pcall(UpdatePassLineVisual) end end)

task.spawn(function() while task.wait(0.1) do if AP.Active then local elapsed=tick()-AP.ActivationTime if elapsed>=AP.Timeout then AP.Active=false if not AP.HasNotifiedTimeout then Notify("Auto Pass","Timeout") AP.HasNotifiedTimeout=true end end end end end)

UIS.InputBegan:Connect(function(i,g) if g then return end if i.KeyCode==AP.ActivationKey then AP.Active=true AP.ActivationTime=tick() AP.HasNotifiedTimeout=false Notify("Auto Pass","Activated") end end)

-- AIMBOT (COMPLETELY REWRITTEN - SIMPLIFIED)
local AB={Enabled=false,Mode="Smart",ShowVisualization=false,TotalHits=0,Key=Enum.KeyCode.Z}
local AO={XOffset=0,CourtDepth=0.35,DownForce=1.5,NetClearance=1.5}
local TP=nil
local TM,TL=nil,nil

local function GetDirectAimbotTarget()
if not CC then return nil end
local cid=CC.Id local pos=SP[cid] if not pos or #pos==0 then return nil end
local idx=1
if PR.Mode=="Cycle" then if PR.CurrentIndex>#pos then PR.CurrentIndex=1 end idx=PR.CurrentIndex
elseif PR.Mode=="Random" then idx=math.random(1,#pos)
elseif PR.Mode=="Closest" then if BD.IsValid and BD.Position then local md=math.huge for i,p in ipairs(pos) do local vp=Vector3.new(p.X,p.Y,p.Z) local d=(vp-BD.Position).Magnitude if d<md then md=d idx=i end end end
elseif PR.Mode=="Safest" then if #TT.Opponents>0 then local bd=-math.huge for i,p in ipairs(pos) do local vp=Vector3.new(p.X,p.Y,p.Z) local md=math.huge for _,opp in ipairs(TT.Opponents) do local op=TT.PredictionEnabled and opp.PredictedPosition or opp.Position local p2=Vector3.new(vp.X,0,vp.Z) local o2=Vector3.new(op.X,0,op.Z) local d=(p2-o2).Magnitude md=math.min(md,d) end if md>bd then bd=md idx=i end end end end
local p=pos[idx] local target=Vector3.new(p.X,p.Y,p.Z)
if AB.Mode=="Smash" then target=Vector3.new(target.X,CC.GroundY+0.3,target.Z)
elseif AB.Mode=="Power" then target=Vector3.new(target.X,target.Y+0.5,target.Z) end
return target
end

local function UV()
if not AB.ShowVisualization or not AB.Enabled then if TM then pcall(function() TM:Destroy() end) TM=nil end if TL then pcall(function() TL:Destroy() end) TL=nil end return end
local t=GetDirectAimbotTarget() if not t then if TM then pcall(function() TM:Destroy() end) TM=nil end if TL then pcall(function() TL:Destroy() end) TL=nil end return end
if not TM then TM=Instance.new("Part") TM.Name="TargetMarker" TM.Shape=Enum.PartType.Ball TM.Material=Enum.Material.Neon TM.Color=Color3.fromRGB(255,100,100) TM.Transparency=0.3 TM.CanCollide=false TM.CanTouch=false TM.Anchored=true TM.Size=Vector3.new(5,5,5) TM.CastShadow=false TM.Parent=WS end
TM.Position=t
if not TL then TL=Instance.new("Part") TL.Name="TargetLine" TL.Material=Enum.Material.Neon TL.Color=Color3.fromRGB(0,255,255) TL.Transparency=0.5 TL.CanCollide=false TL.CanTouch=false TL.Anchored=true TL.Size=Vector3.new(0.4,100,0.4) TL.CastShadow=false TL.Parent=WS end
TL.Position=Vector3.new(t.X,t.Y+50,t.Z)
end

Run.RenderStepped:Connect(function() pcall(UV) end)

local AimDebug = { Enabled = true }

-- RACKET_USE_MOVE hook
local RUM_OS,RUM_HI,RUM_Obj,RUM_Ref=nil,false,nil,nil
local function RUMHook(self,...)
local a={...}
if a[1]=="Swing" and a[2]==false and TP and (AB.Enabled or AP.Active) then
local rt=LP.Character and LP.Character:FindFirstChild("HumanoidRootPart")
if rt then local d=(TP-rt.Position) if d.Magnitude>0.1 then a[3]=d.Unit if AimDebug.Enabled then print(string.format("[ENI] RUM drag(%.2f,%.2f,%.2f)",a[3].X,a[3].Y,a[3].Z)) end end end
end
return RUM_OS(self,a[1],a[2],a[3])
end
task.spawn(function() repeat Run.Heartbeat:Wait() until ML task.wait(1) pcall(function() if GM.Actions and GM.Actions.RACKET_USE_MOVE then RUM_Obj=GM.Actions.RACKET_USE_MOVE RUM_OS=RUM_Obj.Fire RUM_Obj.Fire=RUMHook RUM_Ref=RUMHook RUM_HI=true warn("[ENI] ✅ RUM hooked") end end) end)
task.spawn(function() while task.wait(3) do pcall(function() if RUM_HI and RUM_Obj and RUM_Ref and RUM_Obj.Fire~=RUM_Ref then RUM_OS=RUM_Obj.Fire RUM_Obj.Fire=RUM_Ref end end) end end)

-- USE_SWING hook
local OS,HI,SwingObj,HookRef,SwingObfName,SwingRemoteReady,CapturedSwingArgs=nil,false,nil,nil,nil,false,nil
local function SwingHook(self,...)
local args={...}
CapturedSwingArgs={} for i=1,17 do CapturedSwingArgs[i]=args[i] end
if not SwingRemoteReady and self and type(self)=="table" and self.name then SwingObfName=self.name SwingRemoteReady=true end
local ch=LP.Character local rt=ch and ch:FindFirstChild("HumanoidRootPart")
if not rt then return OS(self,args[1],args[2],args[3],args[4],args[5],args[6],args[7],args[8],args[9],args[10],args[11],args[12],args[13],args[14],args[15],args[16],args[17]) end
local myPos=rt.Position local modified=false
pcall(function()
if not CC then CC=GetPlayerCourt() if CC then pcall(UTT) pcall(function() OCJ(CC.Id) end) end end
if AP.Active then
local tm=GetBestTeammate()
if tm then
local ft=nil local ib,ia=IsTeammateBehindOrAligned(tm)
if ib or ia then ft=CalculateSidewaysEndpoint(myPos,tm.Position) else local th=tm.Character and tm.Character:FindFirstChild("Head") if th then ft=th.Position end end
if ft then
ft=Vector3.new(ft.X,ft.Y+(IsJumping() and AP.JumpingHeight or AP.StandingHeight),ft.Z)
if CC then local cp,cs=CC.FloorPosition,CC.FloorSize ft=Vector3.new(math.clamp(ft.X,cp.X-(cs.X/2)+10,cp.X+(cs.X/2)-10),ft.Y,math.clamp(ft.Z,cp.Z-(cs.Z/2)+10,cp.Z+(cs.Z/2)-10)) end
local pd=(ft-myPos) if pd.Magnitude>0.1 then pd=pd.Unit args[10]=pd.X args[11]=pd.Y args[12]=pd.Z args[13]=false args[14]=false TP=ft modified=true AP.Stats.TotalPasses+=1 AP.Active=false AP.HasNotifiedTimeout=false end
end
end
end
if not modified and AB.Enabled then
local tp=GetDirectAimbotTarget()
if tp then
TP=tp local raw=tp-myPos local hd=Vector3.new(raw.X,0,raw.Z) if hd.Magnitude<0.1 then hd=Vector3.new(0,0,-1) end hd=hd.Unit
local ya=raw.Y/math.max(raw.Magnitude,0.1) local df=AO.DownForce
local h=ch:FindFirstChild("Humanoid") if h then local st=h:GetState() if st==Enum.HumanoidStateType.Freefall or st==Enum.HumanoidStateType.Jumping then df=df*0.3 elseif AB.Mode=="Smash" then df=df*3 elseif AB.Mode=="Power" then df=df*2 end end
local fy=math.clamp(ya-df,-3,1) local dir=Vector3.new(hd.X,fy,hd.Z) if dir.Magnitude>0.01 then dir=dir.Unit args[10]=dir.X args[11]=dir.Y args[12]=dir.Z args[13]=false args[14]=false modified=true AB.TotalHits+=1 IPI() end
end
end
end)
if not modified and AB.Enabled and TP then pcall(function() local fb=TP-myPos local hd=Vector3.new(fb.X,0,fb.Z) if hd.Magnitude>0.1 then hd=hd.Unit local fy=math.clamp(fb.Y/math.max(fb.Magnitude,1)-AO.DownForce,-3,1) local fd=Vector3.new(hd.X,fy,hd.Z).Unit args[10]=fd.X args[11]=fd.Y args[12]=fd.Z args[13]=false args[14]=false end end) end
if AimDebug.Enabled then print(string.format("[ENI] SWING dir(%.2f,%.2f,%.2f) mod:%s RUM:%s",args[10] or 0,args[11] or 0,args[12] or 0,tostring(modified),tostring(RUM_HI))) end
return OS(self,args[1],args[2],args[3],args[4],args[5],args[6],args[7],args[8],args[9],args[10],args[11],args[12],args[13],args[14],args[15],args[16],args[17])
end
local function IUH() if HI then return end if not GM.Actions or not GM.Actions.USE_SWING then return end SwingObj=GM.Actions.USE_SWING OS=SwingObj.Fire SwingObj.Fire=SwingHook HookRef=SwingHook SwingObfName=SwingObj.name if SwingObfName then SwingRemoteReady=true end HI=true warn("[ENI] ✅ SWING hooked") end
task.spawn(function() repeat Run.Heartbeat:Wait() until ML task.wait(2) IUH() end)
task.spawn(function() while task.wait(3) do pcall(function() if HI and SwingObj and HookRef and SwingObj.Fire~=HookRef then OS=SwingObj.Fire SwingObj.Fire=HookRef end end) end end)

-- target updater
task.spawn(function() while true do pcall(function()
if AB.Enabled or AP.Active then
if not CC then CC=GetPlayerCourt() end
if CC then
if AP.Active then local tm=GetBestTeammate() if tm then local ch=LP.Character local rt=ch and ch:FindFirstChild("HumanoidRootPart") if rt then local ib,ia=IsTeammateBehindOrAligned(tm) if ib or ia then TP=CalculateSidewaysEndpoint(rt.Position,tm.Position) or TP else local th=tm.Character and tm.Character:FindFirstChild("Head") if th then TP=th.Position end end end end
elseif AB.Enabled then local t=GetDirectAimbotTarget() if t then TP=t end end
end
else TP=nil end
end) task.wait(0.05) end end)


-- SOUND DETECTION
local SDS={UseSetOnNextSwing=false,LastOppActivateTime=0,LastSetSoundTime=0,StateResetDelay=3.0,SoundIDs={OppActivate="122043805634054",BallOnFire="88312482701427",BallWasSet="102855892658394",OppFreeze="99804515682986"}}

local function IsOppSide(pos) if not CC or not pos then return false end local np=GNP() if not np then return false end local ch=LP.Character if not ch then return false end local rt=ch:FindFirstChild("HumanoidRootPart") if not rt then return false end local nz=np.Z local mz=rt.Position.Z local pz=pos.Z local mySide=mz<nz and "side1" or "side2" local checkSide=pz<nz and "side1" or "side2" return mySide~=checkSide end

WS.DescendantAdded:Connect(function(obj) if not obj:IsA("Sound") then return end local function CS() if not obj.Playing then return end local sid=obj.SoundId if not sid then return end sid=string.match(sid,"%d+") or "" if sid==SDS.SoundIDs.OppActivate then local soundPos=nil if obj.Parent and obj.Parent:IsA("BasePart") then soundPos=obj.Parent.Position elseif BD.IsValid and BD.Position then soundPos=BD.Position end if soundPos and IsOppSide(soundPos) then SDS.UseSetOnNextSwing=true SDS.LastOppActivateTime=tick() end elseif sid==SDS.SoundIDs.BallWasSet then local soundPos=nil if obj.Parent and obj.Parent:IsA("BasePart") then soundPos=obj.Parent.Position elseif BD.IsValid and BD.Position then soundPos=BD.Position end if soundPos and not IsOppSide(soundPos) then SDS.UseSetOnNextSwing=false SDS.LastSetSoundTime=tick() end end end obj:GetPropertyChangedSignal("Playing"):Connect(function() pcall(CS) end) task.delay(0.05,function() pcall(CS) end) end)

task.spawn(function() while task.wait(0.5) do if SDS.UseSetOnNextSwing and (tick()-SDS.LastOppActivateTime)>SDS.StateResetDelay then SDS.UseSetOnNextSwing=false end end end)

-- AUTO AWAKENING
local AAW={Enabled=false,AwakeningKey=Enum.KeyCode.Two,MinBallHeight=3,MaxBallHeight=10,LastUseTime=0,UseCooldown=1.0,Stats={TotalUses=0}}

local function IBNGOS() if not BD.IsValid or not BD.Position or not CC then return false end local bp=BD.Position if not IsOppSide(bp) then return false end local gy=CC.GroundY local bh=bp.Y-gy return bh>=AAW.MinBallHeight and bh<=AAW.MaxBallHeight end

WS.DescendantAdded:Connect(function(obj) if not obj:IsA("Sound") then return end obj:GetPropertyChangedSignal("Playing"):Connect(function() pcall(function() if not obj.Playing or not AAW.Enabled then return end local sid=obj.SoundId if not sid then return end sid=string.match(sid,"%d+") or "" if sid==SDS.SoundIDs.OppFreeze then local soundPos=nil if obj.Parent and obj.Parent:IsA("BasePart") then soundPos=obj.Parent.Position elseif BD.IsValid and BD.Position then soundPos=BD.Position end if soundPos and IsOppSide(soundPos) then task.spawn(function() local maxWait=1.0 local startTime=tick() while (tick()-startTime)<maxWait do if IBNGOS() then if (tick()-AAW.LastUseTime)>=AAW.UseCooldown then for i=1,5 do PK(AAW.AwakeningKey) end AAW.LastUseTime=tick() AAW.Stats.TotalUses+=1 end break end task.wait(0.01) end end) end end end) end) end)

-- AUTO SWING
local AS={Enabled=false,SwingKey=Enum.KeyCode.F,ToggleKey=Enum.KeyCode.T,ReachBuffer=0.5,LastSwingTime=0,SwingCooldown=0,Stats={TotalSwings=0},OnlyWhenSetOnCD=false,SetCDToggleKey=Enum.KeyCode.G,UseSetNextSwing=false,WaitingForSetHit=false}

local function GARR() if Stats.Enabled then return Stats.Values.Reach end local r=14 pcall(function() if GM.PlayerControl and GM.RacketStatUtils then local rv=GM.RacketStatUtils.GetStatForPlayer(GM.PlayerControl,"Reach") if rv and tonumber(rv) then r=tonumber(rv) end end end) return r end

local function IBIR() if not BD.IsValid or not BD.Position or not BD.Velocity then return false end if IBOS() then return false end local ch=LP.Character if not ch then return false end local rt=ch:FindFirstChild("HumanoidRootPart") if not rt then return false end local bp=BD.Position local mp=rt.Position local dp=bp-mp if dp.Magnitude>30 then return false end local d=dp.Magnitude local ar=GARR() local effectiveReach=ar*AS.ReachBuffer local rp=rt.CFrame:PointToObjectSpace(bp) local hd=math.abs(bp.Y-mp.Y) return d<=effectiveReach and rp.Z<effectiveReach and hd<effectiveReach end

local ASC=nil

local function STAS(en)
if ASC then ASC:Disconnect() ASC = nil end
AS.Enabled = en
if en then
if ICS and ICS.Enabled and GM.SharedData and GM.SharedData.GAME then
GM.SharedData.GAME.SWING_CHARGE_DURATION = ICS.CustomDuration
end
ASC = Run.RenderStepped:Connect(function()
if not AS.Enabled then return end
if ICS and ICS.Enabled and GM.SharedData and GM.SharedData.GAME then
GM.SharedData.GAME.SWING_CHARGE_DURATION = ICS.CustomDuration
end
if AS.OnlyWhenSetOnCD and not AP.Active then
local scd = ISOC()
if not scd then return end
end
local ct = tick()
if ct - AS.LastSwingTime < AS.SwingCooldown then return end
if IBIR() then
local useSet = SDS.UseSetOnNextSwing or AS.UseSetNextSwing
local key = useSet and Enum.KeyCode.E or AS.SwingKey
for i = 1, 10 do PK(key) end
AS.LastSwingTime = ct
AS.Stats.TotalSwings += 1
if SDS.UseSetOnNextSwing then SDS.UseSetOnNextSwing = false end
if AS.UseSetNextSwing then
AS.WaitingForSetHit = true
AS.UseSetNextSwing = false
Notify("Auto SET", "Used SET...")
end
end
end)
Notify("Auto Swing", "Enabled")
else
Notify("Auto Swing", "Disabled")
end
end

UIS.InputBegan:Connect(function(i,g) if g then return end if i.KeyCode==AS.ToggleKey then STAS(not AS.Enabled) end if i.KeyCode==AS.SetCDToggleKey then AS.OnlyWhenSetOnCD=not AS.OnlyWhenSetOnCD Notify("Only When Set CD",AS.OnlyWhenSetOnCD and "ON" or "OFF") end if i.KeyCode==Enum.KeyCode.R then AS.UseSetNextSwing=true Notify("Auto SET","Will use SET on next swing") end end)

-- AUTO ABILITIES
local AAF={Enabled=false,GroundDistance=7.0,AbilityKey=Enum.KeyCode.One,Stats={TotalUses=0},LastUseTime=0,UseCooldown=0.001,NetSafetyDistance=15.0,XOffset=0,YOffset=0,ZOffset=0}
local AAN={Enabled=false,AbilityKey=Enum.KeyCode.One,NetDistance=5.08,NetXOffset=0,NetYOffset=0,NetZOffset=0,Stats={TotalUses=0},LastUseTime=0,UseCooldown=0.001}
local AAS={LastServeTime=0,ServeProtectionTime=2,FloorConnection=nil,NetConnection=nil}
local FM={Ball={Enabled=false,Sphere=nil,Stick=nil},NetAbility={Enabled=false,Sphere=nil,Stick=nil,Position=nil},FloorAbility={Enabled=false,Sphere=nil,Stick=nil,Position=nil}}

local function UFAM() if not AAF.Enabled or not CC then FM.FloorAbility.Position=nil return end local np=GNP() if not np then FM.FloorAbility.Position=nil return end local gy=CC.GroundY local ty=gy+tonumber(AAF.GroundDistance)+tonumber(AAF.YOffset) local ch=LP.Character if ch and ch:FindFirstChild("HumanoidRootPart") then local mz=ch.HumanoidRootPart.Position.Z local nz=np.Z local ms=mz<nz and -1 or 1 local mz=nz+(ms*tonumber(AAF.NetSafetyDistance))+tonumber(AAF.ZOffset) local mx=CC.FloorPosition.X+tonumber(AAF.XOffset) FM.FloorAbility.Position=Vector3.new(mx,ty,mz) else FM.FloorAbility.Position=nil end end
local function IBGMS() if not BD.IsValid or not BD.Position then return false end if not CC then return false end if not IBIB() then return false end if IBOS() then return false end local np=GNP() if np then local dz=math.abs(BD.Position.Z-np.Z) if dz<5 then return false end end local bp=BD.Position local gy=CC.GroundY local ha=bp.Y-gy return ha<=tonumber(AAF.GroundDistance)+3 and ha>-1 end
local function CUAF() if not AAF.Enabled then return end local ct=tick() local ts=tick()-AAS.LastServeTime if ts<AAS.ServeProtectionTime then return end if IBGMS() and ILIB() then for i=1,5 do PK(AAF.AbilityKey) end AAF.Stats.TotalUses+=1 AAF.LastUseTime=ct end end
local function STAAF(en) if AAS.FloorConnection then AAS.FloorConnection:Disconnect() AAS.FloorConnection=nil end AAF.Enabled=en FM.FloorAbility.Enabled=en if en then AAS.FloorConnection=Run.RenderStepped:Connect(function() pcall(CUAF) pcall(UFAM) end) Notify("Auto Ability Floor","Enabled") else Notify("Auto Ability Floor","Disabled") end end
local function UNAM() if not AAN.Enabled or not CC then FM.NetAbility.Position=nil return end local np,ns=GNP() if not np or not ns then FM.NetAbility.Position=nil return end local ch=LP.Character if not ch or not ch:FindFirstChild("HumanoidRootPart") then FM.NetAbility.Position=nil return end local mz=ch.HumanoidRootPart.Position.Z local nz=np.Z local ms=mz<nz and -1 or 1 local nty=np.Y+(ns.Y/2) local ty=nty+tonumber(AAN.NetYOffset)+tonumber(AAN.NetDistance) local tx=np.X+tonumber(AAN.NetXOffset) local tz=np.Z+(ms*math.abs(tonumber(AAN.NetZOffset))) FM.NetAbility.Position=Vector3.new(tx,ty,tz) end
local function CUAN() if not AAN.Enabled then return end local ct=tick() if not BD.IsValid or not BD.Position then return end if IBOS() then return end if not CC then return end local ts=tick()-AAS.LastServeTime if ts<AAS.ServeProtectionTime then return end local bp=BD.Position local gy=CC.GroundY local ha=bp.Y-gy if ha<=2 then return end local np,ns=GNP() if not np or not ns then return end local ch=LP.Character if not ch or not ch:FindFirstChild("HumanoidRootPart") then return end local mz=ch.HumanoidRootPart.Position.Z local nz=np.Z local ms=mz<nz and -1 or 1 local nty=np.Y+(ns.Y/2) local ty=nty+tonumber(AAN.NetYOffset)+tonumber(AAN.NetDistance) local tx=np.X+tonumber(AAN.NetXOffset) local tz=np.Z+(ms*math.abs(tonumber(AAN.NetZOffset))) if math.abs(bp.Y-ty)>5.0 then return end if math.abs(bp.X-tx)>25 then return end if math.abs(bp.Z-tz)>6.0 then return end if not ILIB() then return end for i=1,5 do PK(AAN.AbilityKey) end AAN.Stats.TotalUses+=1 AAN.LastUseTime=ct end
local function STAAN(en) if AAS.NetConnection then AAS.NetConnection:Disconnect() AAS.NetConnection=nil end AAN.Enabled=en FM.NetAbility.Enabled=en if en then AAS.NetConnection=Run.RenderStepped:Connect(function() pcall(CUAN) pcall(UNAM) end) Notify("Auto Ability Net","Enabled") else Notify("Auto Ability Net","Disabled") end end

-- VISUAL EFFECTS (HIT EFFECTS - SINGLE SELECT + ALL PLAYERS + NO TIME CHECKS)
local SFXS={Enabled=false,HitVolume=2.5,ChargeVolume=1.5,HitSounds={["Sonic Laser"]="rbxassetid://98888713695139",["Guest1337"]="rbxassetid://128035789183475",["Sparky Hit"]="rbxassetid://689743416",["Laser Hit"]="rbxassetid://107219279957145",["New Hit"]="rbxassetid://95467134693244"},SelectedHitSFX="Sonic Laser",ChargeSounds={["Glaster Charge"]="rbxassetid://9069975578",["Energy Charge"]="rbxassetid://109903968999295",["Power Charge"]="rbxassetid://72621371319494",["One For All"]="rbxassetid://7652343013"},SelectedChargeSFX="One For All",CurrentChargeSound=nil,IsCharging=false,LastM1Press=0}
local HPS={Enabled=false,SelectedCharge="Default"}
local FECE={Enabled=false,SelectedCharge="Default"}
local HB={Enabled=false,Part=nil,Connection=nil}
local ATX={Enabled=false,HoldKey=Enum.KeyCode.C,SelectedKey="B",IsSpamming=false}
local TKO={["B"]=Enum.KeyCode.B,["V"]=Enum.KeyCode.V}
local CharClone={Enabled=false,TargetUsername="",ApplyOnDeath=false,ChangeNames=false,MorphData={FakeName=nil,FakeID=nil,Description=nil}}
local CCC=nil
local ABC=nil

local function PHS() if not SFXS.Enabled then return end task.spawn(function() pcall(function() local sid=SFXS.HitSounds[SFXS.SelectedHitSFX] if not sid then return end local s=Instance.new("Sound") s.Name="HitSFX" s.SoundId=sid s.Volume=SFXS.HitVolume s.Parent=WS s.PlayOnRemove=false s:Play() Debris:AddItem(s,5) end) end) end
local function SCS() if not SFXS.Enabled then return end if SFXS.IsCharging then return end SFXS.IsCharging=true pcall(function() local sid=SFXS.ChargeSounds[SFXS.SelectedChargeSFX] if not sid then return end if SFXS.CurrentChargeSound and SFXS.CurrentChargeSound.Parent then SFXS.CurrentChargeSound:Stop() SFXS.CurrentChargeSound:Destroy() end local s=Instance.new("Sound") s.Name="ChargeSFX" s.SoundId=sid s.Volume=SFXS.ChargeVolume s.Looped=false s.Parent=WS s:Play() SFXS.CurrentChargeSound=s s.Ended:Connect(function() if s and s.Parent then s:Destroy() end end) end) end
local function StCS() if not SFXS.IsCharging then return end SFXS.IsCharging=false pcall(function() if SFXS.CurrentChargeSound and SFXS.CurrentChargeSound.Parent then Tween:Create(SFXS.CurrentChargeSound,TweenInfo.new(0.1),{Volume=0}):Play() task.delay(0.1,function() if SFXS.CurrentChargeSound then SFXS.CurrentChargeSound:Stop() SFXS.CurrentChargeSound:Destroy() SFXS.CurrentChargeSound=nil end end) end end) end
local function GERC() local s,c=pcall(function() if GM.ChargeHandler and GM.ChargeHandler.GetChargeModule then return GM.ChargeHandler.GetChargeModule() end return "Default" end) return s and c or "Default" end
local function SHP(bcf,ic) if not HPS.Enabled then return end task.spawn(function() pcall(function() local cn=HPS.SelectedCharge local cf=LP.PlayerScripts:WaitForChild("ChargeHandler",1) if not cf then return end cf=cf:FindFirstChild("Charges") if cf then local cm=cf:FindFirstChild(cn) or cf:FindFirstChild("Default") if cm then local ht=cm:FindFirstChild("Hit") if ht then local hc=ht:Clone() hc.CFrame=bcf*CFrame.Angles(math.rad(90),0,0) hc.Parent=WS.FX Debris:AddItem(hc,3) task.wait(0.05) local pf=ic and hc:FindFirstChild("ChargedHit") or hc:FindFirstChild("Hit") if pf then for _,o in pairs(pf:GetDescendants()) do if o:IsA("ParticleEmitter") then o:Emit(o:GetAttribute("EmitCount") or 20) elseif o:IsA("Beam") then o.Enabled=true task.delay(0.5,function() o.Enabled=false end) end end end end end end end) end) end
local function GCR() if Stats.Enabled then return Stats.Values.Reach end local r=14 pcall(function() if GM.PlayerControl and GM.RacketStatUtils then local rv=GM.RacketStatUtils.GetStatForPlayer(GM.PlayerControl,"Reach") if rv and tonumber(rv) then r=tonumber(rv) end end end) return r end
local function SHV(en) HB.Enabled=en if en then if HB.Part then HB.Part:Destroy() end local hp=Instance.new("Part") hp.Name="HitboxVisualization" hp.Shape=Enum.PartType.Ball hp.Material=Enum.Material.ForceField hp.Color=Color3.fromRGB(0,255,255) hp.Transparency=0.6 hp.Anchored=true hp.CanCollide=false hp.CanTouch=false hp.CanQuery=false hp.CastShadow=false hp.Size=Vector3.new(1,1,1) hp.Parent=WS HB.Part=hp if HB.Connection then HB.Connection:Disconnect() end HB.Connection=Run.RenderStepped:Connect(function() pcall(function() if not HB.Enabled or not HB.Part or not HB.Part.Parent then return end local ch=LP.Character if not ch then return end local rt=ch:FindFirstChild("HumanoidRootPart") if not rt then return end HB.Part.CFrame=rt.CFrame local cr=GCR() HB.Part.Size=Vector3.new(1,1,1)*cr*2 local bi=false if BD.IsValid and BD.Position then bi=(HB.Part.Position-BD.Position).Magnitude<=(HB.Part.Size.X/2) end HB.Part.Color=bi and Color3.fromRGB(255,0,0) or Color3.fromRGB(0,255,255) if FM and FM.Ball.Sphere and FM.Ball.Sphere.Parent then FM.Ball.Sphere.Color=bi and Color3.fromRGB(255,0,0) or Color3.fromRGB(255,255,0) end end) end) Notify("Hitbox Visualization","Enabled") else if HB.Connection then HB.Connection:Disconnect() HB.Connection=nil end if HB.Part then HB.Part:Destroy() HB.Part=nil end if FM and FM.Ball.Sphere and FM.Ball.Sphere.Parent then FM.Ball.Sphere.Color=Color3.fromRGB(255,255,0) end Notify("Hitbox Visualization","Disabled") end end
local function CFM(nm,col,sz) local m={Sphere=nil,Stick=nil,Name=nm} local s=Instance.new("Part") s.Name=nm.."_Sphere" s.Shape=Enum.PartType.Ball s.Material=Enum.Material.Neon s.Color=col s.Transparency=0.3 s.CanCollide=false s.CanTouch=false s.Anchored=true s.Size=Vector3.new(sz,sz,sz) s.CastShadow=false m.Sphere=s local st=Instance.new("Part") st.Name=nm.."_Stick" st.Shape=Enum.PartType.Cylinder st.Material=Enum.Material.Neon st.Color=col st.Transparency=0.5 st.CanCollide=false st.CanTouch=false st.Anchored=true st.Size=Vector3.new(0.3,0.3,100) st.CastShadow=false m.Stick=st return m end
local function UFM(m,tp,gy) if not m or not m.Sphere or not m.Stick then return end if not tp or not gy then return end pcall(function() m.Sphere.Position=tp local ha=tp.Y-gy local sh=math.max(ha,0.5) local sm=gy+(sh/2) m.Stick.Size=Vector3.new(0.3,0.3,sh) m.Stick.CFrame=CFrame.new(tp.X,sm,tp.Z)*CFrame.Angles(0,0,math.rad(90)) if not m.Sphere.Parent then m.Sphere.Parent=WS end if not m.Stick.Parent then m.Stick.Parent=WS end end) end
local function DFM(m) if not m then return end pcall(function() if m.Sphere then m.Sphere:Destroy() end if m.Stick then m.Stick:Destroy() end end) end
local function SBM(en) FM.Ball.Enabled=en if en then if not FM.Ball.Sphere then local m=CFM("BallMarker",Color3.fromRGB(255,255,0),5) FM.Ball.Sphere=m.Sphere FM.Ball.Stick=m.Stick end Notify("Ball Marker","Enabled") else DFM(FM.Ball) FM.Ball.Sphere=nil FM.Ball.Stick=nil Notify("Ball Marker","Disabled") end end
local function STK() task.spawn(function() pcall(function() local kc=TKO[ATX.SelectedKey] if kc then VIM:SendKeyEvent(true,kc,false,game) VIM:SendKeyEvent(false,kc,false,game) end end) end) end
local ATXC=nil
local function STATX(en) ATX.Enabled=en if ATXC then ATXC:Disconnect() end if en then ATXC=Run.RenderStepped:Connect(function() if ATX.IsSpamming then STK() end end) Notify("Auto Toxic","Enabled") else if ATXC then ATXC:Disconnect() ATXC=nil end ATX.IsSpamming=false Notify("Auto Toxic","Disabled") end end
local function SCC() task.spawn(function() pcall(function() writefile(CCF,Http:JSONEncode({Username=CharClone.TargetUsername,ApplyOnDeath=CharClone.ApplyOnDeath,ChangeNames=CharClone.ChangeNames})) end) end) end
local function ACM(ch,fn,fi,d,cn) task.spawn(function() pcall(function() task.wait(0.3) local h=ch:WaitForChild("Humanoid",10) if not h then return end for _,v in ch:GetDescendants() do if v:IsA("Accessory") or v:IsA("Hat") then v:Destroy() end end for _,v in ch:GetChildren() do if v:IsA("Shirt") or v:IsA("Pants") or v:IsA("ShirtGraphic") or v:IsA("CharacterMesh") then v:Destroy() end end local bc=h:FindFirstChildOfClass("BodyColors") if bc then bc:Destroy() end for _,n in {"Torso","Left Arm","Right Arm","Left Leg","Right Leg"} do local pt=ch:FindFirstChild(n) if pt then for _,v in pt:GetChildren() do if v:IsA("SpecialMesh") then v:Destroy() end end end end local hd=ch:FindFirstChild("Head") if hd then local ms=hd:FindFirstChildOfClass("SpecialMesh") if ms then ms.MeshId="" ms.TextureId="" end end task.wait(0.1) h:ApplyDescriptionClientServer(d) if cn then h.DisplayName=fn end end) end) end
local function AC(un) if not un or un=="" then Notify("Clone","Enter username") return end local fi=tonumber(un) local fn=un local s=pcall(function() if fi then fn=Players:GetNameFromUserIdAsync(fi) else fi=Players:GetUserIdFromNameAsync(fn) fn=Players:GetNameFromUserIdAsync(fi) end end) if not s then Notify("Clone","Invalid user") return end local d=Players:GetHumanoidDescriptionFromUserId(fi) CharClone.MorphData.FakeName=fn CharClone.MorphData.FakeID=fi CharClone.MorphData.Description=d CharClone.TargetUsername=un SCC() if LP.Character then ACM(LP.Character,fn,fi,d,CharClone.ChangeNames) end if CCC then CCC:Disconnect() end if CharClone.ApplyOnDeath then CCC=LP.CharacterAdded:Connect(function(ch) task.wait(1) ACM(ch,fn,fi,d,CharClone.ChangeNames) end) end Notify("Clone","Applied") end
local function STAB(en) if ABC then ABC:Disconnect() end if en then ABC=Run.Heartbeat:Connect(function() pcall(function() local pg=LP.PlayerGui if pg:FindFirstChild("BlindfoldGui") then pg.BlindfoldGui:Destroy() end if pg:FindFirstChild("Vignette_Blindfold") then pg.Vignette_Blindfold.Enabled=false pg.Vignette_Blindfold:Destroy() end end) end) Notify("Anti-Blind","Enabled") end end
local function SMZV(v) LP.CameraMaxZoomDistance=tonumber(v) or 50 end

local OGERC=nil
local lmu=0

UIS.InputBegan:Connect(function(i,g) if g or not ATX.Enabled then return end if i.KeyCode==ATX.HoldKey then ATX.IsSpamming=true end end)
UIS.InputEnded:Connect(function(i) if i.KeyCode==ATX.HoldKey then ATX.IsSpamming=false end end)
UIS.InputBegan:Connect(function(i,g) if g then return end if i.UserInputType==Enum.UserInputType.MouseButton1 then local ts=tick()-SFXS.LastM1Press if ts>0.2 then SFXS.LastM1Press=tick() SCS() end end end)
UIS.InputEnded:Connect(function(i,g) if i.UserInputType==Enum.UserInputType.MouseButton1 then StCS() end end)
UIS.InputBegan:Connect(function(i,g) if g then return end if i.KeyCode==Enum.KeyCode.F1 then TS:TeleportToPlaceInstance(game.PlaceId,game.JobId,LP) end end)
UIS.InputBegan:Connect(function(i,g) if g then return end if i.KeyCode==AB.Key then AB.Enabled=not AB.Enabled Notify("Aimbot Toggle",AB.Enabled and "Enabled" or "Disabled") end end)

Run.RenderStepped:Connect(function() if tick()-lmu<0.016 then return end lmu=tick() if FM.Ball.Enabled and BD.IsValid and BD.Position and CC then if not FM.Ball.Sphere then local m=CFM("BallMarker",Color3.fromRGB(255,255,0),5) FM.Ball.Sphere=m.Sphere FM.Ball.Stick=m.Stick end UFM(FM.Ball,BD.Position,CC.GroundY) else if FM.Ball.Sphere and FM.Ball.Sphere.Parent then FM.Ball.Sphere.Parent=nil FM.Ball.Stick.Parent=nil end end if FM.FloorAbility.Enabled and FM.FloorAbility.Position and CC then if not FM.FloorAbility.Sphere then local m=CFM("FloorAbilityMarker",Color3.fromRGB(255,100,255),4) FM.FloorAbility.Sphere=m.Sphere FM.FloorAbility.Stick=m.Stick end UFM(FM.FloorAbility,FM.FloorAbility.Position,CC.GroundY) else if FM.FloorAbility.Sphere and FM.FloorAbility.Sphere.Parent then FM.FloorAbility.Sphere.Parent=nil FM.FloorAbility.Stick.Parent=nil end end if FM.NetAbility.Enabled and FM.NetAbility.Position and CC then if not FM.NetAbility.Sphere then local m=CFM("NetAbilityMarker",Color3.fromRGB(100,255,255),4) FM.NetAbility.Sphere=m.Sphere FM.NetAbility.Stick=m.Stick end UFM(FM.NetAbility,FM.NetAbility.Position,CC.GroundY) else if FM.NetAbility.Sphere and FM.NetAbility.Sphere.Parent then FM.NetAbility.Sphere.Parent=nil FM.NetAbility.Stick.Parent=nil end end end)

LP.CharacterAdded:Connect(function() 
    task.wait(2) 
    if MS.Enabled then EMV() end 
    if DSS.Active then startdash() end
    ARD.LastBallSide=nil ARD.HasRotatedForCross=false ARD.HasDashedForCross=false 
    for k in pairs(WK) do WK[k]=false end 
end)
task.spawn(function() while task.wait(0.5) do pcall(function() if BD.IsValid and BD.Position and CC then local gy=CC.GroundY local bh=BD.Position.Y-gy if bh>20 and BD.Velocity and BD.Velocity.Magnitude<10 then AAS.LastServeTime=tick() end end end) end end)
task.spawn(function() while task.wait(60) do pcall(function() local ch=LP.Character if ch then local h=ch:FindFirstChild("Humanoid") if h then local a=h:FindFirstChild("Animator") if a then local t=a:GetPlayingAnimationTracks() if #t>50 then for i=1,#t-50 do pcall(function() t[i]:Stop() t[i]:Destroy() end) end end end end end end) end end)
task.spawn(function() while task.wait(5) do pcall(function() local TVM=require(RS.Packages.ToolVisibilityManager) for i=1,200 do pcall(function() TVM.RemoveForceVisibilityLock("RacketSwing"..i,LP) end) end end) end end)

-- BALL_HIT EVENT (HIT EFFECTS FOR ALL PLAYERS - NO TIME CHECKS)
task.spawn(function()
repeat task.wait(0.1) until ML
task.wait(3)
pcall(function()
if not GM.Actions or not GM.Actions.BALL_HIT then return end
GM.Actions.BALL_HIT:Connect(function(bcf, ic)
-- Hit effects for ALL players (no time check)
if SFXS.Enabled then PHS() end
if HPS.Enabled then SHP(bcf, ic) end

-- Auto Pass deactivation
if AP.Active then
local ballPos=BD.Position
if ballPos and CC then
local np=GNP()
if np then
local char=LP.Character
local root=char and char:FindFirstChild("HumanoidRootPart")
if root then
local nz=np.Z
local mz=root.Position.Z
local bz=ballPos.Z
local mySide=mz<nz and "side1" or "side2"
local ballSide=bz<nz and "side1" or "side2"
if ballSide==mySide then
AP.Active=false
Notify("Auto Pass","Teammate received!")
AP.HasNotifiedTimeout=true
end
end
end
end
end
end)
end)
end)

task.spawn(function() repeat Run.Heartbeat:Wait() until ML task.wait(2) pcall(function() if GM.ChargeHandler then local che=getfenv(GM.ChargeHandler.GetChargeModule) if che.GetEquippedRacketCharge then OGERC=che.GetEquippedRacketCharge che.GetEquippedRacketCharge=function() if FECE.Enabled then return FECE.SelectedCharge end return OGERC() end end end end) end)
task.spawn(function() task.wait(3) pcall(function() if isfile(CCF) then local cfg=Http:JSONDecode(readfile(CCF)) if cfg.Username and cfg.Username~="" then CharClone.TargetUsername=cfg.Username CharClone.ApplyOnDeath=cfg.ApplyOnDeath or false CharClone.ChangeNames=cfg.ChangeNames or false AC(cfg.Username) end end end) end)

-- UI POPULATION (COMPRESSED)
Tabs.Position:AddParagraph({Title="Position System",Content="Click to place, switch with LeftCtrl"})
Tabs.Position:AddDropdown("PositionCount",{Title="Number of Positions",Values={"1","2","3","4","5","6","7","8","9","10"},Multi=false,Default=1,Callback=function(v) PS.SelectedCount=tonumber(v) end})
Tabs.Position:AddButton({Title="Select Positions",Callback=function() SPSel(PS.SelectedCount) end})
Tabs.Position:AddButton({Title="Switch Sides (LeftCtrl)",Callback=MSP})
Tabs.Position:AddToggle("AutoSwitchPos",{Title="Auto Switch on Side Change",Default=false,Callback=function(v) ASP.Enabled=v end})
Tabs.Position:AddButton({Title="Clear All Positions",Callback=function() if CC then SP[CC.Id]=nil writefile(CF,Http:JSONEncode(SP)) ClearPM() Notify("Positions","Cleared") end end})
Tabs.Position:AddDropdown("PositionMode",{Title="Rotation Mode",Values={"Cycle","Random","Closest","Safest"},Multi=false,Default=1,Callback=function(v) PR.Mode=v end})
Tabs.Position:AddToggle("OpponentDetection",{Title="Opponent Detection",Default=false,Callback=function(v) SOPD(v) end})
Tabs.Position:AddSlider("MinSafeDist",{Title="Min Safe Distance",Min=5,Max=30,Default=15,Rounding=1,Callback=function(v) OPD.MinSafeDistance=tonumber(v) end})
Tabs.Position:AddToggle("ShowMarkers",{Title="Show Position Markers",Default=true,Callback=function(v) SM=v if v then UPM() else ClearPM() end end})
Tabs.Position:AddParagraph({Title="Auto Awakening",Content="Auto-press 2 when opp uses freeze"})
Tabs.Position:AddToggle("AutoAwakening",{Title="Enable Auto Awakening",Default=false,Callback=function(v) AAW.Enabled=v end})
Tabs.Position:AddSlider("AwkMinHeight",{Title="Min Ball Height",Min=0,Max=30,Default=3,Rounding=1,Callback=function(v) AAW.MinBallHeight=tonumber(v) end})
Tabs.Position:AddSlider("AwkMaxHeight",{Title="Max Ball Height",Min=0,Max=30,Default=10,Rounding=1,Callback=function(v) AAW.MaxBallHeight=tonumber(v) end})
Tabs.Main:AddParagraph({Title="Max Distance Boundary",Content="Green = safe | Red = too far"})
Tabs.Main:AddButton({Title="Set Boundary (Click Floor)",Callback=SSBS})
Tabs.Main:AddButton({Title="Clear Boundary",Callback=CLB})
Tabs.Main:AddParagraph({Title="Auto Ability Floor",Content=""})
Tabs.Main:AddToggle("AutoFloor",{Title="Enable Auto Ability Floor",Default=false,Callback=function(v) STAAF(v) end})
Tabs.Main:AddSlider("FloorDist",{Title="Ground Distance",Min=0,Max=15,Default=7,Rounding=1,Callback=function(v) AAF.GroundDistance=tonumber(v) UFAM() end})
Tabs.Main:AddSlider("NetSafety",{Title="Net Safety Distance",Min=0,Max=30,Default=15,Rounding=1,Callback=function(v) AAF.NetSafetyDistance=tonumber(v) UFAM() end})
Tabs.Main:AddSlider("FloorX",{Title="Floor X Offset",Min=-20,Max=20,Default=0,Rounding=1,Callback=function(v) AAF.XOffset=tonumber(v) UFAM() end})
Tabs.Main:AddSlider("FloorY",{Title="Floor Y Offset",Min=-10,Max=10,Default=0,Rounding=1,Callback=function(v) AAF.YOffset=tonumber(v) UFAM() end})
Tabs.Main:AddSlider("FloorZ",{Title="Floor Z Offset",Min=-20,Max=20,Default=0,Rounding=1,Callback=function(v) AAF.ZOffset=tonumber(v) UFAM() end})
Tabs.Main:AddParagraph({Title="Auto Ability Net",Content=""})
Tabs.Main:AddToggle("AutoNet",{Title="Enable Auto Ability Net",Default=false,Callback=function(v) STAAN(v) end})
Tabs.Main:AddSlider("NetDist",{Title="Net Distance",Min=0,Max=15,Default=5.08,Rounding=2,Callback=function(v) AAN.NetDistance=tonumber(v) UNAM() end})
Tabs.Main:AddSlider("NetX",{Title="Net X Offset",Min=-20,Max=20,Default=0,Rounding=1,Callback=function(v) AAN.NetXOffset=tonumber(v) UNAM() end})
Tabs.Main:AddSlider("NetY",{Title="Net Y Offset",Min=-10,Max=10,Default=0,Rounding=1,Callback=function(v) AAN.NetYOffset=tonumber(v) UNAM() end})
Tabs.Main:AddSlider("NetZ",{Title="Net Z Offset",Min=0,Max=20,Default=0,Rounding=1,Callback=function(v) AAN.NetZOffset=tonumber(v) UNAM() end})
Tabs.Main:AddToggle("BallMarker",{Title="Ball Marker",Default=false,Callback=function(v) SBM(v) end})
Tabs.Main:AddToggle("AutoToxic",{Title="Auto Toxic",Default=false,Callback=function(v) STATX(v) end})
Tabs.Main:AddKeybind("ToxicKey",{Title="Hold Key",Mode="Hold",Default="C",ChangedCallback=function(v) ATX.HoldKey=v end})
Tabs.Main:AddDropdown("ToxicSticker",{Title="Sticker Key",Values={"B","V"},Multi=false,Default=1,Callback=function(v) ATX.SelectedKey=v end})

Tabs.Combat:AddParagraph({Title="Aimbot (REWRITTEN)",Content="Simplified direction calculation"})
Tabs.Combat:AddToggle("Aimbot",{Title="Enable Aimbot",Default=false,Callback=function(v) AB.Enabled=v end})
Tabs.Combat:AddKeybind("AimbotKey",{Title="Toggle Aimbot",Mode="Toggle",Default="Z",Callback=function(v) AB.Enabled=v end,ChangedCallback=function(v) AB.Key=v end})
Tabs.Combat:AddToggle("AimbotVis",{Title="Show Target Visualization",Default=false,Callback=function(v) AB.ShowVisualization=v end})
Tabs.Combat:AddDropdown("AimbotMode",{Title="Aimbot Mode",Values={"Smart","Smash","Power"},Multi=false,Default=1,Callback=function(v) AB.Mode=v end})
Tabs.Combat:AddInput("CourtDepth",{Title="Court Depth",Default="0.35",Numeric=true,Callback=function(v) local n=tonumber(v) if n then AO.CourtDepth=n end end})
Tabs.Combat:AddInput("DownForce",{Title="Down Force",Default="1.5",Numeric=true,Callback=function(v) local n=tonumber(v) if n then AO.DownForce=n end end})
Tabs.Combat:AddInput("NetClearance",{Title="Net Clearance",Default="1.5",Numeric=true,Callback=function(v) local n=tonumber(v) if n then AO.NetClearance=n end end})
Tabs.Combat:AddInput("XOffset",{Title="X Offset",Default="0",Numeric=true,Callback=function(v) local n=tonumber(v) if n then AO.XOffset=n end end})
Tabs.Combat:AddToggle("AimViewer",{Title="Aim Viewer (L-Shape)",Default=false,Callback=function(v) AV.Enabled=v if not v then for p,_ in pairs(AV.Beams) do clearav(p) end end end})
Tabs.Combat:AddSlider("AVLength",{Title="Aim Line Length",Min=10,Max=50,Default=20,Rounding=1,Callback=function(v) AV.Length=tonumber(v) end})
Tabs.Combat:AddSlider("AVDrop",{Title="Aim Line Drop",Min=5,Max=30,Default=12,Rounding=1,Callback=function(v) AV.Drop=tonumber(v) end})
Tabs.Combat:AddParagraph({Title="Auto Pass (REWRITTEN)",Content="Press P - Fresh teammate detection"})
Tabs.Combat:AddKeybind("AutoPassKey",{Title="Activation Key",Mode="Standard",Default="P",ChangedCallback=function(v) AP.ActivationKey=v end})
Tabs.Combat:AddToggle("APLineVisible",{Title="Line Always Visible",Default=true,Callback=function(v) AP.LineAlwaysVisible=v end})
Tabs.Combat:AddSlider("APTimeout",{Title="Timeout (seconds)",Min=0,Max=10,Default=2,Rounding=1,Callback=function(v) AP.Timeout=tonumber(v) end})
Tabs.Combat:AddSlider("APStandHeight",{Title="Standing Pass Height",Min=0,Max=30,Default=0,Rounding=1,Callback=function(v) AP.StandingHeight=tonumber(v) end})
Tabs.Combat:AddSlider("APJumpHeight",{Title="Jumping Pass Height",Min=0,Max=30,Default=0,Rounding=1,Callback=function(v) AP.JumpingHeight=tonumber(v) end})
Tabs.Combat:AddSlider("APLineLength",{Title="Sideways Distance",Min=5,Max=50,Default=15,Rounding=1,Callback=function(v) AP.LineLength=tonumber(v) end})
Tabs.Combat:AddParagraph({Title="Auto Swing",Content="Fixed reach buffer"})
Tabs.Combat:AddToggle("AutoSwing",{Title="Enable Auto Swing",Default=false,Callback=function(v) STAS(v) end})
Tabs.Combat:AddKeybind("SwingKey",{Title="Toggle Auto Swing",Mode="Toggle",Default="T",Callback=function(v) STAS(v) end})
Tabs.Combat:AddToggle("SwingSetCD",{Title="Only When Set on Cooldown",Default=false,Callback=function(v) AS.OnlyWhenSetOnCD=v end})
Tabs.Combat:AddInput("ReachBuffer",{Title="Reach Buffer",Default="0.5",Numeric=true,Callback=function(v) local n=tonumber(v) if n then AS.ReachBuffer=n end end})

Tabs.Stats:AddToggle("Stats",{Title="Enable Stats Changer",Default=false,Callback=function(v) Stats.Enabled=v if v then ASD() end end})
Tabs.Stats:AddInput("DashDist",{Title="Dash Distance",Default="25",Numeric=true,Callback=function(v) local n=tonumber(v) if n then Stats.Values.DashDistance=n if Stats.Enabled then ASD() end end end})
Tabs.Stats:AddInput("Reach",{Title="Reach",Default="14",Numeric=true,Callback=function(v) local n=tonumber(v) if n then Stats.Values.Reach=n end end})
Tabs.Stats:AddInput("HitSpeed",{Title="Hit Speed",Default="1",Numeric=true,Callback=function(v) local n=tonumber(v) if n then Stats.Values.HitSpeed=n end end})
Tabs.Stats:AddInput("Speed",{Title="Speed",Default="16",Numeric=true,Callback=function(v) local n=tonumber(v) if n then Stats.Values.Speed=n end end})
Tabs.Stats:AddToggle("Movement",{Title="Movement Stats (Instant + Debuff-Aware)",Default=false,Callback=function(v) MS.Enabled=v if v then EMV() end end})
Tabs.Stats:AddInput("WalkSpeed",{Title="Walk Speed",Default="16",Numeric=true,Callback=function(v) local n=tonumber(v) if n then MS.WalkSpeed=n if MS.Enabled then EMV() end end end})
Tabs.Stats:AddInput("JumpPower",{Title="Jump Power",Default="50",Numeric=true,Callback=function(v) local n=tonumber(v) if n then MS.JumpPower=n if MS.Enabled then EMV() end end end})
Tabs.Stats:AddInput("DashSpeedVal",{Title="Dash Speed (20=2x)",Default="20",Numeric=true,Callback=function(v) DSS.Speed=tonumber(v) or 20 end})
Tabs.Stats:AddInput("GravityVal",{Title="Gravity (0.7=def,2=fast fall)",Default="0.7",Numeric=true,Callback=function(v) GS.Gravity=tonumber(v) or 0.7 end})
Tabs.Stats:AddToggle("DashSpeedToggle",{Title="Enable Dash Speed",Default=false,Callback=function(en) DSS.Active=en if en then startdash() else if DSS.Conn then DSS.Conn:Disconnect() DSS.Conn=nil end end end})
Tabs.Stats:AddToggle("GravityToggle",{Title="Enable Fast Fall",Default=false,Callback=function(en) if en then hookgrav() end end})

Tabs.Effects:AddToggle("HitParticles",{Title="Hit Particles (All Players)",Default=false,Callback=function(v) HPS.Enabled=v end})
Tabs.Effects:AddDropdown("ParticleCharge",{Title="Select Charge",Values=CT,Multi=false,Default=1,Callback=function(v) HPS.SelectedCharge=v end})
Tabs.Effects:AddToggle("SFX",{Title="Hit SFX (All Players)",Default=false,Callback=function(v) SFXS.Enabled=v if not v then StCS() end end})
Tabs.Effects:AddDropdown("HitSound",{Title="Hit Sound",Values={"Sonic Laser","Guest1337","Sparky Hit","Laser Hit","New Hit"},Multi=false,Default=1,Callback=function(v) SFXS.SelectedHitSFX=v end})
Tabs.Effects:AddSlider("HitVol",{Title="Hit Volume",Min=0,Max=5,Default=2.5,Rounding=1,Callback=function(v) SFXS.HitVolume=tonumber(v) end})
Tabs.Effects:AddDropdown("ChargeSound",{Title="Charge Sound",Values={"Glaster Charge","Energy Charge","Power Charge","One For All"},Multi=false,Default=4,Callback=function(v) SFXS.SelectedChargeSFX=v end})
Tabs.Effects:AddSlider("ChargeVol",{Title="Charge Volume",Min=0,Max=5,Default=1.5,Rounding=1,Callback=function(v) SFXS.ChargeVolume=tonumber(v) end})
Tabs.Effects:AddToggle("FECharge",{Title="FE Charge",Default=false,Callback=function(v) FECE.Enabled=v end})
Tabs.Effects:AddDropdown("FEChargeType",{Title="Charge Type",Values=CT,Multi=false,Default=1,Callback=function(v) FECE.SelectedCharge=v end})

Tabs.Misc:AddParagraph({Title="Auto Rotation (IMPROVED)",Content="Better net crossing detection"})
Tabs.Misc:AddToggle("AutoRotDash",{Title="Auto Rotation + Dash",Default=false,Callback=function(v) ARD.Enabled=v ARD.LastBallSide=nil ARD.HasRotatedForCross=false ARD.HasDashedForCross=false end})
Tabs.Misc:AddKeybind("AutoRotKey",{Title="Toggle Auto Rotation",Mode="Toggle",Default="5",ChangedCallback=function(v) ARD.ToggleKey=v end})
Tabs.Misc:AddToggle("DetectBallLanding",{Title="Use Ball Landing Marker",Default=true,Callback=function(v) ARD.UseLandingForRotation=v end})
Tabs.Misc:AddSlider("BallOffset",{Title="Offset: 0=Ball | 30=Landing",Min=0,Max=30,Default=0,Rounding=1,Callback=function(v) ARD.BallOffsetDistance=tonumber(v) end})
Tabs.Misc:AddSlider("ActivationDelay",{Title="Activation Delay",Min=0,Max=2,Default=0,Rounding=2,Callback=function(v) ARD.ActivationDelay=tonumber(v) end})
Tabs.Misc:AddParagraph({Title="Manual Rotation (Q Key)",Content="0=ball | 15=middle | 30=landing"})
Tabs.Misc:AddToggle("ManualRotation",{Title="Manual Rotation (Q Key)",Default=false,Callback=function(v) MR.Enabled=v end})
Tabs.Misc:AddToggle("ManualUseLanding",{Title="Use Ball Landing Marker",Default=false,Callback=function(v) MR.UseLandingSpot=v end})
Tabs.Misc:AddSlider("ManualOffset",{Title="Offset: 0=Ball | 30=Landing",Min=0,Max=30,Default=0,Rounding=1,Callback=function(v) MR.BallOffsetDistance=tonumber(v) end})
Tabs.Misc:AddToggle("ManualIgnoreOpp",{Title="Rotate Even on Opp Side",Default=false,Callback=function(v) MR.IgnoreOppSide=v end})
Tabs.Misc:AddToggle("Hitbox",{Title="Hitbox Visualization",Default=false,Callback=function(v) SHV(v) end})
Tabs.Misc:AddToggle("BallLandingMarker",{Title="Ball Landing Marker",Default=false,Callback=function(v) BLM.Enabled=v end})
Tabs.Misc:AddSlider("LineLength",{Title="Max Line Length",Min=10,Max=200,Default=100,Rounding=1,Callback=function(v) BLM.UserSetLength=tonumber(v) end})
Tabs.Misc:AddInput("CloneUser",{Title="Clone Username/ID",Default="",Placeholder="Username or UserID",Callback=function(v) CharClone.TargetUsername=v end})
Tabs.Misc:AddButton({Title="Clone Avatar",Callback=function() if CharClone.TargetUsername~="" then AC(CharClone.TargetUsername) end end})
Tabs.Misc:AddToggle("CloneOnDeath",{Title="Apply Clone on Death",Default=false,Callback=function(v) CharClone.ApplyOnDeath=v SCC() if v and CharClone.MorphData.FakeName then if CCC then CCC:Disconnect() end CCC=LP.CharacterAdded:Connect(function(c) task.wait(1) ACM(c,CharClone.MorphData.FakeName,CharClone.MorphData.FakeID,CharClone.MorphData.Description,CharClone.ChangeNames) end) end end})
Tabs.Misc:AddToggle("CloneNames",{Title="Change Display Name",Default=false,Callback=function(v) CharClone.ChangeNames=v SCC() end})
Tabs.Misc:AddToggle("InstantCharge",{Title="Instant Charge",Default=false,Callback=function(v) STIC(v) end})
Tabs.Misc:AddInput("ChargeDur",{Title="Charge Duration",Default="0.001",Numeric=true,Callback=function(v) local n=tonumber(v) if n then SICD(n) end end})
Tabs.Misc:AddToggle("OppPred",{Title="Opponent Prediction",Default=false,Callback=function(v) TT.PredictionEnabled=v end})
Tabs.Misc:AddInput("PredTime",{Title="Prediction Time",Default="0.5",Numeric=true,Callback=function(v) local n=tonumber(v) if n then TT.PredictionTime=n end end})
Tabs.Misc:AddToggle("NoDashCD",{Title="No Dash Cooldown",Default=false,Callback=function(v) STNDC(v) end})
Tabs.Misc:AddToggle("AntiBlind",{Title="Anti-Blind",Default=false,Callback=function(v) STAB(v) end})
Tabs.Misc:AddSlider("MaxZoom",{Title="Max Camera Zoom",Min=0,Max=300,Default=50,Rounding=0,Callback=function(v) SMZV(v) end})
Tabs.Misc:AddButton({Title="Rejoin Server (F1)",Callback=function() TS:TeleportToPlaceInstance(game.PlaceId,game.JobId,LP) end})

Tabs.Settings:AddKeybind("UIToggle",{Title="UI Toggle Key",Mode="Toggle",Default="End",ChangedCallback=function(v) if Window then Window.MinimizeKey=v end end})

pcall(function() SaveManager:BuildConfigSection(Tabs.Settings) end)
pcall(function() InterfaceManager:BuildInterfaceSection(Tabs.Settings) end)

Tabs.Settings:AddButton({Title="Export Positions",Callback=function() pcall(function() setclipboard(Http:JSONEncode({Legacy=SP})) Notify("Export","Copied to clipboard") end) end})
Tabs.Settings:AddButton({Title="Import Positions",Callback=function() pcall(function() local d=Http:JSONDecode(getclipboard()) if d.Legacy then SP=d.Legacy writefile(CF,Http:JSONEncode(SP)) end UPM() Notify("Import","Loaded from clipboard") end) end})

task.spawn(function()
task.wait(1)
local success, err=pcall(function()
SaveManager:LoadAutoloadConfig()
end)
if not success then
warn("SaveManager: Config corrupted, using defaults")
Notify("Config","Using default settings")
end
end)

print("=== SCRIPT COMPLETE - v14.7 ===")
print("✅ Aimbot: Completely rewritten (simplified)")
print("✅ Auto Pass: Fresh teammate detection (no race conditions)")
print("✅ Hit Effects: Single-select, ALL players, no time checks")
print("✅ Ball Detection: Ball Shadow ONLY")
print("✅ Movement Stats: Instant persistence + debuff-aware")
print("✅ Auto Rotation: Improved net crossing detection")
print("❌ REMOVED: Dash Speed, No Ability CD, No Serve CD")

-- NEW FEATURES

-- SWING HIT RADIUS
local SHR={Enabled=false,Value=14,Original=14}
task.spawn(function() repeat Run.Heartbeat:Wait() until ML pcall(function() if GM.SharedData and GM.SharedData.GAME then SHR.Original=GM.SharedData.GAME.SWING_HIT_RADIUS or 14 end end) end)
local function SetSHR(en)
    SHR.Enabled=en
    pcall(function()
        if GM.SharedData and GM.SharedData.GAME then
            GM.SharedData.GAME.SWING_HIT_RADIUS=en and SHR.Value or SHR.Original
        end
    end)
end
task.spawn(function() while task.wait(0.5) do if SHR.Enabled and GM.SharedData and GM.SharedData.GAME then GM.SharedData.GAME.SWING_HIT_RADIUS=SHR.Value end end end)

-- BALL TARGET READER
local BTR={Enabled=false,TargetPlayer=nil,TargetLabel=nil,IsTargetingMe=false}
local function GetBallTarget()
    if not ActiveObject then return nil end
    local tid=rawget(ActiveObject,"TargetUserId")
    if tid and tid~=0 then
        local s,p=pcall(function() return Players:GetPlayerByUserId(tid) end)
        if s and p then return p end
    end
    return nil
end
local function UpdateBTR()
    if not BTR.Enabled then
        if BTR.TargetLabel and BTR.TargetLabel.Parent then BTR.TargetLabel.Parent=nil end
        return
    end
    local tp=GetBallTarget()
    BTR.TargetPlayer=tp
    BTR.IsTargetingMe=tp and tp==LP or false
    if not BTR.TargetLabel then
        local bg=Instance.new("BillboardGui") bg.Name="BallTargetLabel" bg.Size=UDim2.new(0,200,0,50) bg.StudsOffset=Vector3.new(0,5,0) bg.AlwaysOnTop=true
        local tl=Instance.new("TextLabel") tl.Size=UDim2.new(1,0,1,0) tl.BackgroundTransparency=1 tl.TextColor3=Color3.fromRGB(255,255,0) tl.TextScaled=true tl.Font=Enum.Font.GothamBold tl.TextStrokeTransparency=0 tl.Parent=bg
        BTR.TargetLabel=bg
    end
    if BD.IsValid and BD.Position and ActiveObject then
        local body=rawget(ActiveObject,"Body")
        if body and body.Parent then
            local tl=BTR.TargetLabel:FindFirstChildOfClass("TextLabel")
            if tl then
                tl.Text=tp and ("-> "..tp.Name) or "No Target"
                tl.TextColor3=BTR.IsTargetingMe and Color3.fromRGB(255,0,0) or Color3.fromRGB(255,255,0)
            end
            BTR.TargetLabel.Adornee=body
            BTR.TargetLabel.Parent=game:GetService("CoreGui")
        end
    else
        if BTR.TargetLabel then BTR.TargetLabel.Parent=nil end
    end
end
task.spawn(function() while task.wait(0.05) do pcall(UpdateBTR) end end)

-- ANTI-DEBUFF LOCK BYPASS
local ADB={Enabled=false,Connection=nil}
local function SetADB(en)
    ADB.Enabled=en
    if ADB.Connection then ADB.Connection:Disconnect() ADB.Connection=nil end
    if en then
        ADB.Connection=Run.Heartbeat:Connect(function()
            pcall(function()
                if not ADB.Enabled then return end
                local ui=require(RF:WaitForChild("ui",1))
                if ui and ui.PlayerControl and ui.PlayerControl.Movement then
                    local mv=ui.PlayerControl.Movement
                    if mv.AnchorLock then pcall(function() mv.AnchorLock:Unlock() end) end
                    if mv.JumpLock then pcall(function() mv.JumpLock:Unlock() end) end
                    if mv.DashLock then pcall(function() mv.DashLock:Unlock() end) end
                    if mv.MovementLock then pcall(function() mv.MovementLock:Unlock() end) end
                    mv.CanMove=true
                    mv.CanJump=true
                    mv.CanDash=true
                end
                if GM.MovementHandler and GM.MovementHandler.Instance then
                    local mh=GM.MovementHandler.Instance
                    if mh.AnchorLock then pcall(function() mh.AnchorLock:Unlock() end) end
                    if mh.JumpLock then pcall(function() mh.JumpLock:Unlock() end) end
                    if mh.DashLock then pcall(function() mh.DashLock:Unlock() end) end
                    if mh.MovementLock then pcall(function() mh.MovementLock:Unlock() end) end
                    mh.CanMove=true
                    mh.CanJump=true
                    mh.CanDash=true
                end
            end)
        end)
    end
end

-- MULTI DASH + JUMP
local MDJ={DashCount=1,ExtraJumps=1,DoubleJumpPower=70,Enabled=false,Connection=nil}
local function SetMDJ(en)
    MDJ.Enabled=en
    if MDJ.Connection then MDJ.Connection:Disconnect() MDJ.Connection=nil end
    if en then
        MDJ.Connection=Run.Heartbeat:Connect(function()
            pcall(function()
                if not MDJ.Enabled then return end
                local ui=require(RF:WaitForChild("ui",1))
                if ui and ui.PlayerControl and ui.PlayerControl.Movement then
                    local mv=ui.PlayerControl.Movement
                    mv.DashCount=MDJ.DashCount
                    mv.ExtraJumpCount=MDJ.ExtraJumps
                    mv.CanDoubleJump=MDJ.ExtraJumps>0
                    mv.DoubleJumpPower=MDJ.DoubleJumpPower
                    mv.DashUsed=0
                    mv.UsedJumpCount=0
                end
                if GM.MovementHandler and GM.MovementHandler.Instance then
                    local mh=GM.MovementHandler.Instance
                    mh.DashCount=MDJ.DashCount
                    mh.ExtraJumpCount=MDJ.ExtraJumps
                    mh.CanDoubleJump=MDJ.ExtraJumps>0
                    mh.DoubleJumpPower=MDJ.DoubleJumpPower
                    mh.DashUsed=0
                    mh.UsedJumpCount=0
                end
            end)
        end)
    end
end

-- RACKET COOLDOWN NUKE
local RCN={Enabled=false,OriginalCooldowns=nil}
local function SetRCN(en)
    RCN.Enabled=en
    pcall(function()
        if GM.SharedData and GM.SharedData.GAME and GM.SharedData.GAME.RACKET_COOLDOWNS then
            if en then
                if not RCN.OriginalCooldowns then
                    RCN.OriginalCooldowns={}
                    for k,v in pairs(GM.SharedData.GAME.RACKET_COOLDOWNS) do RCN.OriginalCooldowns[k]=v end
                end
                for k,v in pairs(GM.SharedData.GAME.RACKET_COOLDOWNS) do
                    if type(v)=="number" then GM.SharedData.GAME.RACKET_COOLDOWNS[k]=0 end
                end
            else
                if RCN.OriginalCooldowns then
                    for k,v in pairs(RCN.OriginalCooldowns) do GM.SharedData.GAME.RACKET_COOLDOWNS[k]=v end
                end
            end
        end
    end)
end
task.spawn(function() while task.wait(1) do if RCN.Enabled then pcall(function() if GM.SharedData and GM.SharedData.GAME and GM.SharedData.GAME.RACKET_COOLDOWNS then for k,v in pairs(GM.SharedData.GAME.RACKET_COOLDOWNS) do if type(v)=="number" then GM.SharedData.GAME.RACKET_COOLDOWNS[k]=0 end end end end) end end end)

-- ANTI-HALT
local AH={Enabled=false,Connection=nil}
local function SetAH(en)
    AH.Enabled=en
    if AH.Connection then AH.Connection:Disconnect() AH.Connection=nil end
    if en then
        pcall(function()
            local fh=RS:FindFirstChild("ForceHalt")
            if fh then fh.Value=false end
            local lc=RS:FindFirstChild("LockCamera")
            if lc then lc.Value=false end
            local brd=RS:FindFirstChild("BodyRotationDisabled")
            if brd then brd.Value=false end
        end)
        AH.Connection=Run.Heartbeat:Connect(function()
            pcall(function()
                local fh=RS:FindFirstChild("ForceHalt")
                if fh and fh.Value then fh.Value=false end
                local lc=RS:FindFirstChild("LockCamera")
                if lc and lc.Value then lc.Value=false end
                local brd=RS:FindFirstChild("BodyRotationDisabled")
                if brd and brd.Value then brd.Value=false end
            end)
        end)
    end
end

-- LOB CONTROL
local LC={Enabled=false,Angle=28,Original=28}
task.spawn(function() repeat Run.Heartbeat:Wait() until ML pcall(function() if GM.SharedData and GM.SharedData.GAME then LC.Original=GM.SharedData.GAME.LOB_THRESHOLD_ANGLE or 28 end end) end)
local function SetLC(en)
    LC.Enabled=en
    pcall(function()
        if GM.SharedData and GM.SharedData.GAME then
            GM.SharedData.GAME.LOB_THRESHOLD_ANGLE=en and LC.Angle or LC.Original
        end
    end)
end
task.spawn(function() while task.wait(1) do if LC.Enabled and GM.SharedData and GM.SharedData.GAME then GM.SharedData.GAME.LOB_THRESHOLD_ANGLE=LC.Angle end end end)

-- AWAKENING CHARGE SPEED
local ACS={Enabled=false,Multiplier=5,Original=nil}
local function SetACS(en)
    ACS.Enabled=en
    pcall(function()
        if GM.SharedData and GM.SharedData.GAME and GM.SharedData.GAME.AWAKENING_CHARGE then
            if en then
                if not ACS.Original then ACS.Original={} for k,v in pairs(GM.SharedData.GAME.AWAKENING_CHARGE) do ACS.Original[k]=v end end
                for k,v in pairs(GM.SharedData.GAME.AWAKENING_CHARGE) do
                    if type(v)=="number" then GM.SharedData.GAME.AWAKENING_CHARGE[k]=v*ACS.Multiplier end
                end
            else
                if ACS.Original then for k,v in pairs(ACS.Original) do GM.SharedData.GAME.AWAKENING_CHARGE[k]=v end end
            end
        end
        if GM.SharedData and GM.SharedData.GAME and GM.SharedData.GAME.AWAKENING_CHARGE_MULTIPLIER then
            if en then
                for k,v in pairs(GM.SharedData.GAME.AWAKENING_CHARGE_MULTIPLIER) do
                    if type(v)=="number" then GM.SharedData.GAME.AWAKENING_CHARGE_MULTIPLIER[k]=v*ACS.Multiplier end
                end
            end
        end
    end)
end

-- FRIEND BONUS MOD
local FBM={Enabled=false,YenBonus=2.0,WinBonus=0.5,OriginalYen=nil,OriginalWin=nil}
local function SetFBM(en)
    FBM.Enabled=en
    pcall(function()
        if GM.SharedData and GM.SharedData.FRIEND_BONUS then
            if en then
                if not FBM.OriginalYen then FBM.OriginalYen=GM.SharedData.FRIEND_BONUS.YEN_BONUS or 0.5 end
                if not FBM.OriginalWin then FBM.OriginalWin=GM.SharedData.FRIEND_BONUS.WINS_TOTAL_YEN_BONUS or 0.1 end
                GM.SharedData.FRIEND_BONUS.YEN_BONUS=FBM.YenBonus
                GM.SharedData.FRIEND_BONUS.WINS_TOTAL_YEN_BONUS=FBM.WinBonus
            else
                if FBM.OriginalYen then GM.SharedData.FRIEND_BONUS.YEN_BONUS=FBM.OriginalYen end
                if FBM.OriginalWin then GM.SharedData.FRIEND_BONUS.WINS_TOTAL_YEN_BONUS=FBM.OriginalWin end
            end
        end
    end)
end
task.spawn(function() while task.wait(1) do if FBM.Enabled then pcall(function() if GM.SharedData and GM.SharedData.FRIEND_BONUS then GM.SharedData.FRIEND_BONUS.YEN_BONUS=FBM.YenBonus GM.SharedData.FRIEND_BONUS.WINS_TOTAL_YEN_BONUS=FBM.WinBonus end end) end end end)

-- BALL MAX DISTANCE MOD
local BMD={Enabled=false,Value=250,Original=200}
task.spawn(function() repeat Run.Heartbeat:Wait() until ML pcall(function() if GM.SharedData and GM.SharedData.GAME then BMD.Original=GM.SharedData.GAME.BALL_MAX_DISTANCE_FROM_NET or 200 end end) end)
local function SetBMD(en)
    BMD.Enabled=en
    pcall(function()
        if GM.SharedData and GM.SharedData.GAME then
            GM.SharedData.GAME.BALL_MAX_DISTANCE_FROM_NET=en and BMD.Value or BMD.Original
        end
    end)
end
task.spawn(function() while task.wait(1) do if BMD.Enabled and GM.SharedData and GM.SharedData.GAME then GM.SharedData.GAME.BALL_MAX_DISTANCE_FROM_NET=BMD.Value end end end)

-- BALL RADIUS MOD
local BRM={Enabled=false,Value=3,Connection=nil}
local function SetBRM(en)
    BRM.Enabled=en
    if BRM.Connection then BRM.Connection:Disconnect() BRM.Connection=nil end
    if en then
        BRM.Connection=Run.Heartbeat:Connect(function()
            pcall(function()
                if not BRM.Enabled or not ActiveObject then return end
                local r=rawget(ActiveObject,"Radius")
                if r and type(r)=="number" then
                    rawset(ActiveObject,"Radius",BRM.Value)
                end
            end)
        end)
    end
end

-- NO LEAVING PENALTY (ban + elo combined)
local NLP={Enabled=false,OriginalBanMin=nil,OriginalBanMax=nil,OriginalEloMin=nil,OriginalEloMax=nil}
local function SetNLP(en)
    NLP.Enabled=en
    pcall(function()
        if GM.SharedData and GM.SharedData.RANKED then
            if en then
                if not NLP.OriginalBanMin then NLP.OriginalBanMin=GM.SharedData.RANKED.LEAVING_BAN_MIN_DURATION or 60 end
                if not NLP.OriginalBanMax then NLP.OriginalBanMax=GM.SharedData.RANKED.LEAVING_BAN_MAX_DURATION or 600 end
                if not NLP.OriginalEloMin then NLP.OriginalEloMin=GM.SharedData.RANKED.LEAVING_ELO_PENALTY_MIN or 10 end
                if not NLP.OriginalEloMax then NLP.OriginalEloMax=GM.SharedData.RANKED.LEAVING_ELO_PENALTY_MAX or 25 end
                GM.SharedData.RANKED.LEAVING_BAN_MIN_DURATION=0
                GM.SharedData.RANKED.LEAVING_BAN_MAX_DURATION=0
                GM.SharedData.RANKED.LEAVING_ELO_PENALTY_MIN=0
                GM.SharedData.RANKED.LEAVING_ELO_PENALTY_MAX=0
            else
                if NLP.OriginalBanMin then GM.SharedData.RANKED.LEAVING_BAN_MIN_DURATION=NLP.OriginalBanMin end
                if NLP.OriginalBanMax then GM.SharedData.RANKED.LEAVING_BAN_MAX_DURATION=NLP.OriginalBanMax end
                if NLP.OriginalEloMin then GM.SharedData.RANKED.LEAVING_ELO_PENALTY_MIN=NLP.OriginalEloMin end
                if NLP.OriginalEloMax then GM.SharedData.RANKED.LEAVING_ELO_PENALTY_MAX=NLP.OriginalEloMax end
            end
        end
    end)
end
task.spawn(function() while task.wait(1) do if NLP.Enabled then pcall(function() if GM.SharedData and GM.SharedData.RANKED then GM.SharedData.RANKED.LEAVING_BAN_MIN_DURATION=0 GM.SharedData.RANKED.LEAVING_BAN_MAX_DURATION=0 GM.SharedData.RANKED.LEAVING_ELO_PENALTY_MIN=0 GM.SharedData.RANKED.LEAVING_ELO_PENALTY_MAX=0 end end) end end end)

-- NEW UI ELEMENTS
local NewTab=Window:AddTab({Title="Advanced",Icon="cpu"})

NewTab:AddParagraph({Title="Swing Hit Radius",Content="Increase ball hit detection range"})
NewTab:AddToggle("SHRToggle",{Title="Enable Hit Radius Mod",Default=false,Callback=function(v) SetSHR(v) end})
NewTab:AddSlider("SHRValue",{Title="Hit Radius",Min=14,Max=100,Default=14,Rounding=1,Callback=function(v) SHR.Value=tonumber(v) if SHR.Enabled then SetSHR(true) end end})

NewTab:AddParagraph({Title="Ball Target Reader",Content="Shows who the ball is aimed at"})
NewTab:AddToggle("BTRToggle",{Title="Show Ball Target",Default=false,Callback=function(v) BTR.Enabled=v end})

NewTab:AddParagraph({Title="Anti-Debuff",Content="Bypass movement locks from abilities"})
NewTab:AddToggle("ADBToggle",{Title="Anti-Debuff Lock",Default=false,Callback=function(v) SetADB(v) end})

NewTab:AddParagraph({Title="Multi Dash + Jump",Content="Multiple dashes and extra jumps"})
NewTab:AddToggle("MDJToggle",{Title="Enable Multi Dash/Jump",Default=false,Callback=function(v) SetMDJ(v) end})
NewTab:AddSlider("DashCountSlider",{Title="Dash Count",Min=1,Max=10,Default=1,Rounding=0,Callback=function(v) MDJ.DashCount=tonumber(v) end})
NewTab:AddSlider("ExtraJumpsSlider",{Title="Extra Jumps",Min=0,Max=10,Default=1,Rounding=0,Callback=function(v) MDJ.ExtraJumps=tonumber(v) end})
NewTab:AddSlider("DJPowerSlider",{Title="Double Jump Power",Min=10,Max=200,Default=70,Rounding=0,Callback=function(v) MDJ.DoubleJumpPower=tonumber(v) end})

NewTab:AddParagraph({Title="Racket Cooldowns",Content="Zero all swing type cooldowns"})
NewTab:AddToggle("RCNToggle",{Title="No Racket Cooldowns",Default=false,Callback=function(v) SetRCN(v) end})

NewTab:AddParagraph({Title="Anti-Halt/Freeze",Content="Prevents game from freezing you"})
NewTab:AddToggle("AHToggle",{Title="Anti-Halt",Default=false,Callback=function(v) SetAH(v) end})

NewTab:AddParagraph({Title="Lob Control",Content="Change lob detection angle threshold"})
NewTab:AddToggle("LCToggle",{Title="Enable Lob Control",Default=false,Callback=function(v) SetLC(v) end})
NewTab:AddSlider("LCAngle",{Title="Lob Angle (lower=more lobs)",Min=1,Max=90,Default=28,Rounding=0,Callback=function(v) LC.Angle=tonumber(v) if LC.Enabled then SetLC(true) end end})

NewTab:AddParagraph({Title="Awakening Charge Speed",Content="Build awakening faster"})
NewTab:AddToggle("ACSToggle",{Title="Fast Awakening Charge",Default=false,Callback=function(v) SetACS(v) end})
NewTab:AddSlider("ACSMult",{Title="Charge Multiplier",Min=1,Max=20,Default=5,Rounding=0,Callback=function(v) ACS.Multiplier=tonumber(v) end})

NewTab:AddParagraph({Title="Friend Bonus",Content="Boost yen from friend games"})
NewTab:AddToggle("FBMToggle",{Title="Friend Yen Bonus",Default=false,Callback=function(v) SetFBM(v) end})
NewTab:AddSlider("FBMYen",{Title="Yen Bonus Multiplier",Min=0.5,Max=10,Default=2,Rounding=1,Callback=function(v) FBM.YenBonus=tonumber(v) if FBM.Enabled then SetFBM(true) end end})
NewTab:AddSlider("FBMWin",{Title="Win Yen Bonus",Min=0.1,Max=5,Default=0.5,Rounding=1,Callback=function(v) FBM.WinBonus=tonumber(v) if FBM.Enabled then SetFBM(true) end end})

NewTab:AddParagraph({Title="Ball Max Distance",Content="How far ball can travel from net"})
NewTab:AddToggle("BMDToggle",{Title="Ball Distance Mod",Default=false,Callback=function(v) SetBMD(v) end})
NewTab:AddSlider("BMDValue",{Title="Max Distance",Min=200,Max=350,Default=250,Rounding=0,Callback=function(v) BMD.Value=tonumber(v) if BMD.Enabled then SetBMD(true) end end})

NewTab:AddParagraph({Title="Ball Radius",Content="Change ball hitbox size"})
NewTab:AddToggle("BRMToggle",{Title="Ball Radius Mod",Default=false,Callback=function(v) SetBRM(v) end})
NewTab:AddSlider("BRMValue",{Title="Ball Radius",Min=1,Max=10,Default=3,Rounding=1,Callback=function(v) BRM.Value=tonumber(v) end})

NewTab:AddParagraph({Title="No Leaving Penalty",Content="No ban + no elo loss when leaving ranked"})
NewTab:AddToggle("NLPToggle",{Title="No Leave Penalty",Default=false,Callback=function(v) SetNLP(v) end})
